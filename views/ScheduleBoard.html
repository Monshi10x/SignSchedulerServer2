<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Schedule Board</title>

  <!-- Firebase (compat build keeps the current non-module script structure simple) -->
  <script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore-compat.js"></script>

  <style>
    :root{
      --bg:#0b0d12;
      --panel:#111521;
      --panel2:#0f1320;
      --text:#e9eefc;
      --muted:#9aa6c3;
      --line:#1e2640;
      --accent:#4ea1ff;
      --danger:#ff4e6a;

      --headerH:56px;
      --dayHeaderH:42px;
      --monthRowH:28px;
      --timeColW:72px;
      --slotH:22px;

      --radius:14px;
      --shadow: 0 10px 30px rgba(0,0,0,.35);

      --btnShadow: 0 6px 14px rgba(0,0,0,.28);
      --btnShadowDown: 0 3px 8px rgba(0,0,0,.22);

      --insetShadow: inset 0 2px 4px rgba(0,0,0,.55), inset 0 0 0 1px rgba(255,255,255,.04);

      --sideW: 320px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background: radial-gradient(1200px 700px at 10% 0%, rgba(78,161,255,.18), transparent 50%),
                  radial-gradient(900px 600px at 90% 20%, rgba(255,78,106,.12), transparent 55%),
                  var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      overflow:hidden;
    }

    /* Header */
    .appHeader{
      position:sticky; top:0;
      height:var(--headerH);
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      background: rgba(11,13,18,.86);
      backdrop-filter: blur(10px);
      border-bottom:1px solid rgba(255,255,255,.06);
      z-index:50;
    }
    .brand{display:flex; align-items:center; gap:10px; min-width: 170px;}
    .brandBadge{
      width:34px;height:34px;border-radius:11px;
      background: linear-gradient(135deg, rgba(78,161,255,.9), rgba(255,78,106,.8));
      box-shadow: 0 10px 24px rgba(78,161,255,.18);
    }
    .brandTitle{font-weight:800; letter-spacing:.2px; line-height:1}
    .brandSub{font-size:12px; color:var(--muted); margin-top:2px}

    .headerLeft, .headerRight{display:flex; align-items:center; gap:8px;}
    .headerLeft{flex:1}
    .headerRight{margin-left:auto}

    .btn, .chip, select, input[type="date"], input[type="text"], input[type="number"], textarea{
      font:inherit;
    }

    .btn{
      display:inline-flex; align-items:center; justify-content:center; gap:8px;
      height:36px; padding:0 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      color:var(--text);
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      box-shadow: var(--btnShadow);
      transform: translateY(0);
      transition: box-shadow .12s ease, transform .12s ease, background .12s ease;
    }
    .btn:hover{background: rgba(255,255,255,.06)}
    .btn:active{ box-shadow: var(--btnShadowDown); transform: translateY(1px); }
    .btn.primary{
      border-color: rgba(78,161,255,.35);
      background: rgba(78,161,255,.12);
    }
    .btn.danger{
      border-color: rgba(255,78,106,.35);
      background: rgba(255,78,106,.12);
    }
    .btn.icon{width:36px;padding:0}
    .cardBtn.done:hover{ background: rgba(46,229,157,.22); border-color: rgba(46,229,157,.55); color:#eafff7; box-shadow: 0 8px 18px rgba(46,229,157,.35); }

    .btn .ico{
      width:18px;height:18px; display:inline-block;
      background: currentColor;
      mask-size: contain; mask-repeat:no-repeat; mask-position:center;
      -webkit-mask-size: contain; -webkit-mask-repeat:no-repeat; -webkit-mask-position:center;
    }

    .ico.chevL{mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="black" d="M15.5 19 8.5 12l7-7 1.5 1.5L11.5 12 17 17.5z"/></svg>'); -webkit-mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="black" d="M15.5 19 8.5 12l7-7 1.5 1.5L11.5 12 17 17.5z"/></svg>');}
    .ico.chevR{mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="black" d="M8.5 19 7 17.5 12.5 12 7 6.5 8.5 5l7 7z"/></svg>'); -webkit-mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="black" d="M8.5 19 7 17.5 12.5 12 7 6.5 8.5 5l7 7z"/></svg>');}
    .ico.chevLL{mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill=\"black\" d=\"m17.5 19-7-7 7-7 1.5 1.5L12.5 12l6.5 6.5Zm-7 0-7-7 7-7L12 6.5 5.5 12 12 17.5Z\"/></svg>'); -webkit-mask-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path fill=\"black\" d=\"m17.5 19-7-7 7-7 1.5 1.5L12.5 12l6.5 6.5Zm-7 0-7-7 7-7L12 6.5 5.5 12 12 17.5Z\"/></svg>');}
    .ico.chevRR{mask-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path fill=\"black\" d=\"m6.5 5 7 7-7 7-1.5-1.5L11.5 12 5 6.5Zm7 0 7 7-7 7-1.5-1.5L18.5 12 12 6.5Z\"/></svg>'); -webkit-mask-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path fill=\"black\" d=\"m6.5 5 7 7-7 7-1.5-1.5L11.5 12 5 6.5Zm7 0 7 7-7 7-1.5-1.5L18.5 12 12 6.5Z\"/></svg>');}
    .ico.today{mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="black" d="M7 2h2v2h6V2h2v2h3v18H2V4h3V2h2v2Zm13 6H4v12h16V8ZM6 10h4v4H6v-4Z"/></svg>'); -webkit-mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="black" d="M7 2h2v2h6V2h2v2h3v18H2V4h3V2h2v2Zm13 6H4v12h16V8ZM6 10h4v4H6v-4Z"/></svg>');}
    .ico.plus{mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="black" d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2h6z"/></svg>'); -webkit-mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="black" d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2h6z"/></svg>');}
    .ico.cog{mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="black" d="M19.14 12.94c.04-.31.06-.63.06-.94s-.02-.63-.06-.94l2.03-1.58a.5.5 0 0 0 .12-.64l-1.92-3.32a.5.5 0 0 0-.6-.22l-2.39.96a7.08 7.08 0 0 0-1.63-.94l-.36-2.54A.5.5 0 0 0 13.9 1h-3.8a.5.5 0 0 0-.49.42l-.36 2.54c-.58.24-1.12.55-1.63.94l-2.39-.96a.5.5 0 0 0-.6.22L2.71 7.48a.5.5 0 0 0 .12.64l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58a.5.5 0 0 0-.12.64l1.92 3.32c.13.23.4.32.64.22l2.39-.96c.5.39 1.05.7 1.63.94l.36 2.54c.04.24.25.42.49.42h3.8c.24 0 .45-.18.49-.42l.36-2.54c.58-.24 1.12-.55 1.63-.94l2.39.96c.24.1.51.01.64-.22l1.92-3.32a.5.5 0 0 0-.12-.64l-2.03-1.58ZM12 15.5A3.5 3.5 0 1 1 12 8a3.5 3.5 0 0 1 0 7.5Z"/></svg>'); -webkit-mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="black" d="M19.14 12.94c.04-.31.06-.63.06-.94s-.02-.63-.06-.94l2.03-1.58a.5.5 0 0 0 .12-.64l-1.92-3.32a.5.5 0 0 0-.6-.22l-2.39.96a7.08 7.08 0 0 0-1.63-.94l-.36-2.54A.5.5 0 0 0 13.9 1h-3.8a.5.5 0 0 0-.49.42l-.36 2.54c-.58.24-1.12.55-1.63.94l-2.39-.96a.5.5 0 0 0-.6.22L2.71 7.48a.5.5 0 0 0 .12.64l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58a.5.5 0 0 0-.12.64l1.92 3.32c.13.23.4.32.64.22l2.39-.96c.5.39 1.05.7 1.63.94l.36 2.54c.04.24.25.42.49.42h3.8c.24 0 .45-.18.49-.42l.36-2.54c.58-.24 1.12-.55 1.63-.94l2.39.96c.24.1.51.01.64-.22l1.92-3.32a.5.5 0 0 0-.12-.64l-2.03-1.58ZM12 15.5A3.5 3.5 0 1 1 12 8a3.5 3.5 0 0 1 0 7.5Z"/></svg>');}
    .ico.pencil{mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="black" d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25ZM20.71 7.04a1.003 1.003 0 0 0 0-1.42l-2.34-2.34a1.003 1.003 0 0 0-1.42 0L15.13 5.1l3.75 3.75 1.83-1.81Z"/></svg>'); -webkit-mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="black" d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25ZM20.71 7.04a1.003 1.003 0 0 0 0-1.42l-2.34-2.34a1.003 1.003 0 0 0-1.42 0L15.13 5.1l3.75 3.75 1.83-1.81Z"/></svg>');}
    .ico.trash{mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="black" d="M7 21q-.825 0-1.412-.587T5 19V6H4V4h5V3h6v1h5v2h-1v13q0 .825-.587 1.413T17 21H7Zm10-15H7v13h10V6ZM9 17h2V8H9v9Zm4 0h2V8h-2v9Z"/></svg>'); -webkit-mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="black" d="M7 21q-.825 0-1.412-.587T5 19V6H4V4h5V3h6v1h5v2h-1v13q0 .825-.587 1.413T17 21H7Zm10-15H7v13h10V6ZM9 17h2V8H9v9Zm4 0h2V8h-2v9Z"/></svg>');}
    .ico.play{mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="black" d="M8 5v14l11-7z"/></svg>'); -webkit-mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="black" d="M8 5v14l11-7z"/></svg>');}
    .ico.stop{mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="black" d="M6 6h12v12H6z"/></svg>'); -webkit-mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="black" d="M6 6h12v12H6z"/></svg>');}
    .ico.clock{mask-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill=\"black\" d=\"M12 22q-2.075 0-3.9-.788t-3.187-2.125Q3.575 17.75 2.788 15.925 2 14.1 2 12t.788-3.9q.787-1.825 2.125-3.162Q7.25 3.575 9.075 2.788 10.9 2 13 2t3.9.788q1.825.787 3.163 2.125 1.337 1.337 2.124 3.162Q23 10.9 23 13q0 2.1-.788 3.925-.787 1.825-2.124 3.162-1.338 1.337-3.163 2.125Q14.075 22 12 22Zm0-2q3.35 0 5.675-2.325Q20 15.35 20 12q0-3.35-2.325-5.675Q15.35 4 12 4 8.65 4 6.325 6.325 4 8.65 4 12q0 3.35 2.325 5.675Q8.65 20 12 20Zm.5-7h3v-2h-2v-4h-2v6Z\"/></svg>'); -webkit-mask-image:url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path fill=\"black\" d=\"M12 22q-2.075 0-3.9-.788t-3.187-2.125Q3.575 17.75 2.788 15.925 2 14.1 2 12t.788-3.9q.787-1.825 2.125-3.162Q7.25 3.575 9.075 2.788 10.9 2 13 2t3.9.788q1.825.787 3.163 2.125 1.337 1.337 2.124 3.162Q23 10.9 23 13q0 2.1-.788 3.925-.787 1.825-2.124 3.162-1.338 1.337-3.163 2.125Q14.075 22 12 22Zm0-2q3.35 0 5.675-2.325Q20 15.35 20 12q0-3.35-2.325-5.675Q15.35 4 12 4 8.65 4 6.325 6.325 4 8.65 4 12q0 3.35 2.325 5.675Q8.65 20 12 20Zm.5-7h3v-2h-2v-4h-2v6Z\"/></svg>');}
    .ico.check{mask-image:url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path fill=\"black\" d=\"M9.55 18.45 3.1 12l1.4-1.4 5.05 5.05L19.5 5.7l1.4 1.4Z\"/></svg>'); -webkit-mask-image:url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path fill=\"black\" d=\"M9.55 18.45 3.1 12l1.4-1.4 5.05 5.05L19.5 5.7l1.4 1.4Z\"/></svg>');}
    .ico.plusCircle{mask-image:url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path fill=\"black\" d=\"M11 17h2v-4h4v-2h-4V7h-2v4H7v2h4Zm1 5q-2.075 0-3.9-.788t-3.187-2.125Q3.575 17.75 2.788 15.925 2 14.1 2 12t.788-3.9q.787-1.825 2.125-3.162Q6.25 3.575 8.075 2.788 9.9 2 12 2t3.9.788q1.825.787 3.163 2.125 1.337 1.337 2.124 3.162Q23 9.9 23 12t-.788 3.925q-.787 1.825-2.124 3.162-1.338 1.337-3.163 2.125Q14.075 22 12 22Zm0-2q3.35 0 5.675-2.325Q20 15.35 20 12q0-3.35-2.325-5.675Q15.35 4 12 4 8.65 4 6.325 6.325 4 8.65 4 12q0 3.35 2.325 5.675Q8.65 20 12 20Z\"/></svg>'); -webkit-mask-image:url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path fill=\"black\" d=\"M11 17h2v-4h4v-2h-4V7h-2v4H7v2h4Zm1 5q-2.075 0-3.9-.788t-3.187-2.125Q3.575 17.75 2.788 15.925 2 14.1 2 12t.788-3.9q.787-1.825 2.125-3.162Q6.25 3.575 8.075 2.788 9.9 2 12 2t3.9.788q1.825.787 3.163 2.125 1.337 1.337 2.124 3.162Q23 9.9 23 12t-.788 3.925q-.787 1.825-2.124 3.162-1.338 1.337-3.163 2.125Q14.075 22 12 22Zm0-2q3.35 0 5.675-2.325Q20 15.35 20 12q0-3.35-2.325-5.675Q15.35 4 12 4 8.65 4 6.325 6.325 4 8.65 4 12q0 3.35 2.325 5.675Q8.65 20 12 20Z\"/></svg>');}

    .pill{
      height:36px;
      display:flex; align-items:center; gap:8px;
      padding:0 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      color:var(--text);
      max-width: 270px;
    }
    .pillTitle{white-space:nowrap; overflow:hidden; text-overflow:ellipsis; font-weight:700}
    .pillMeta{font-size:12px; color:var(--muted); white-space:nowrap}

    .select{
      height:36px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.92);
      color:#0b0d12;
      padding:0 10px;
      outline:none;
      box-shadow: var(--btnShadow);
      transition: box-shadow .12s ease, transform .12s ease;
    }
    .select:active{ box-shadow: var(--btnShadowDown); transform: translateY(1px); }
    .select option{color:#0b0d12;background:#ffffff;}

    .modal select{color: var(--text);background: rgba(0,0,0,.20);}
    .modal select option{color: var(--text);background: #111521;}

    .seg{
      height:36px; display:flex; align-items:center; gap:10px;
      border-radius:12px;
      padding:0 10px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      min-width: 120px;
      box-shadow: var(--btnShadow);
      transition: box-shadow .12s ease, transform .12s ease;
    }
    .seg:active{ box-shadow: var(--btnShadowDown); transform: translateY(1px); }

    .appBody{
      height: calc(100vh - var(--headerH));
      display:flex;
      flex-direction:column;
      overflow:hidden;
    }

    /* Layout: main + unassigned panel */
    .layout{
      height:100%;
      display:flex;
      overflow:hidden;
      position:relative;
    }
    .mainArea{
      flex: 1 1 auto;
      min-width: 0;
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }

    /* Unassigned panel */
    .sidePanel{
      width: var(--sideW);
      max-width: 90vw;
      height:100%;
      border-left:1px solid rgba(255,255,255,.08);
      background: rgba(17,21,33,.55);
      backdrop-filter: blur(10px);
      display:flex;
      flex-direction:column;
      overflow:hidden;
      transition: transform .18s ease;
    }
    .sidePanel.hidden{
      transform: translateX(100%);
      pointer-events:none;
      position:absolute;
      right:0; top:0; bottom:0;
    }
    .sideHeader{
      padding: 10px 10px 8px 10px;
      border-bottom:1px solid rgba(255,255,255,.08);
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .sideHeaderTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
    }
    .sideTitle{
      font-weight:950;
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      gap:8px;
      min-width: 0;
    }
    .sideTitle .countBadge{
      font-size:11px;
      color: rgba(154,166,195,.95);
      border:1px solid rgba(255,255,255,.10);
      padding:3px 7px;
      border-radius:999px;
      background: rgba(0,0,0,.18);
      flex:0 0 auto;
    }
    .sideControls{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .sideControls input, .sideControls select{
      height:34px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      color: var(--text);
      padding: 0 10px;
      outline:none;
      box-shadow: var(--insetShadow);
      min-width: 0;
    }
    .sideControls select option{background:#111521;color:var(--text)}
    .sideList{
      overflow:auto;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
      scrollbar-width: thin;
      scrollbar-color: rgba(255,255,255,.12) transparent;
    }
    .sideList::-webkit-scrollbar{width:10px}
    .sideList::-webkit-scrollbar-thumb{background: rgba(255,255,255,.12); border-radius:20px}
    .dropHint{
      margin: 0 10px 10px 10px;
      padding:10px;
      border-radius:14px;
      border:1px dashed rgba(255,255,255,.14);
      background: rgba(0,0,0,.14);
      color: var(--muted);
      font-size:12px;
      line-height:1.35;
    }
    .sideDropActive .dropHint{
      border-color: rgba(78,161,255,.55);
      background: rgba(78,161,255,.12);
      color: rgba(233,238,252,.92);
    }

    /* Board */
    .boardWrap{
      position:relative;
      height:100%;
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }

    .timeline{
      height:100%;
      display:grid;
      grid-template-rows: calc(var(--dayHeaderH) + var(--monthRowH)) 1fr;
      overflow:hidden;
      border-top: 1px solid rgba(255,255,255,.06);
    }
    .timelineTop{
      display:grid;
      grid-template-columns: var(--timeColW) 1fr;
      grid-template-rows: var(--monthRowH) var(--dayHeaderH);
      background: rgba(17,21,33,.6);
      backdrop-filter: blur(10px);
      border-bottom:1px solid rgba(255,255,255,.06);
      z-index:10;
    }
    .timeHeader{
      height: calc(var(--dayHeaderH) + var(--monthRowH));
      display:flex; align-items:center; justify-content:center;
      color:var(--muted);
      font-size:12px;
      border-right:1px solid rgba(255,255,255,.06);
      grid-row: 1 / span 2;
    }
    .monthBar{
      grid-column: 2;
      grid-row: 1;
      display:flex;
      align-items:center;
      padding: 0 10px;
      border-bottom:1px solid rgba(255,255,255,.06);
      font-weight:950;
      letter-spacing:.2px;
      color: var(--text);
      overflow:hidden;
      white-space:nowrap;
      text-overflow:ellipsis;
    }
    .monthBar .muted{
      font-weight:800;
      color: var(--muted);
      margin-left:10px;
      font-size:12px;
    }

    .daysHeader{
      grid-column: 2;
      grid-row: 2;
      display:flex;
      overflow:auto;
      scrollbar-width: none;
    }
    .daysHeader::-webkit-scrollbar{display:none}

    .dayHead{
      flex:1 0 210px;
      min-width: 210px;
      height:var(--dayHeaderH);
      display:flex; align-items:center; justify-content:space-between;
      padding:0 10px;
      border-right:1px solid rgba(255,255,255,.06);
      color:var(--text);
      gap: 10px;
    }
    .dayHead.today{background: rgba(78,161,255,.10)}
    .dayHead.wideToday{flex-basis: 420px; min-width:420px;}
    .dayCol.wideToday{flex-basis: 420px; min-width:420px;}

    /* ✅ #5: Single-line "Wed 30" */
    .dayHead .dLine{
      font-weight:950;
      font-size:14px;
      line-height:1;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .dayHead .count{
      font-size:11px;
      color: rgba(154,166,195,.9);
      border:1px solid rgba(255,255,255,.10);
      padding:3px 7px;
      border-radius:999px;
      background: rgba(0,0,0,.12);
      opacity: .75;
      flex:0 0 auto;
    }

    .timelineBottom{
      display:grid;
      grid-template-columns: var(--timeColW) 1fr;
      overflow:hidden;
    }

    .timeRail{
      position:relative;
      overflow:auto;
      border-right:1px solid rgba(255,255,255,.06);
      background: rgba(17,21,33,.40);
      scrollbar-width: none;
    }
    .timeRail::-webkit-scrollbar{display:none}
    .timeRailInner{position:relative;width:100%;}
    .timeLabel{
      position:absolute;
      left:0; right:0;
      height:1px;
      color:var(--muted);
      font-size:11px;
      padding-left:10px;
      transform: translateY(-7px);
      pointer-events:none;
      opacity:.92;
      white-space:nowrap;
    }
    .timeLabel::after{
      content:"";
      position:absolute;
      left:0; right:0;
      top:7px;
      border-top:1px solid rgba(255,255,255,.08);
      opacity:.55;
    }

    .daysGrid{
      position:relative;
      overflow:auto;
      background: rgba(15,19,32,.40);
      scrollbar-width: thin;
      scrollbar-color: rgba(255,255,255,.12) transparent;
      touch-action: pan-x pan-y;
    }
    .daysGrid::-webkit-scrollbar{height:10px;width:10px}
    .daysGrid::-webkit-scrollbar-thumb{background: rgba(255,255,255,.12); border-radius:20px}
    .daysGrid::-webkit-scrollbar-track{background: transparent}

    .daysGridInner{
      position:relative;
      display:flex;
      min-height: 100%;
    }

    .dayCol{
      position:relative;
      flex:1 0 210px;
      min-width:210px;
      border-right:1px solid rgba(255,255,255,.06);
      background: linear-gradient(to bottom, rgba(255,255,255,.03), rgba(255,255,255,.00) 22%);
      user-select:none;
    }

    .slotLine{
      position:absolute;
      left:0; right:0;
      height:1px;
      border-top:1px solid rgba(255,255,255,.06);
      pointer-events:none;
    }
    .slotLine.hour{border-top:1px solid rgba(255,255,255,.12)}
    .slotLine.half{border-top:1px dashed rgba(255,255,255,.10)}

    .nowLine{
      position:absolute;
      left:0; right:0;
      height:2px;
      background: rgba(255,78,106,.95);
      box-shadow: 0 0 0 1px rgba(0,0,0,.25), 0 6px 18px rgba(255,78,106,.25);
      pointer-events:none;
      z-index: 5;
    }
    .nowDot{
      position:absolute;
      left:6px;
      top:50%;
      width:10px;height:10px;border-radius:50%;
      transform: translateY(-50%);
      background: rgba(255,78,106,.95);
      box-shadow: 0 0 0 2px rgba(0,0,0,.35);
    }

    /* Tasks */
    .task{
      position:absolute;
      left:8px;
      right:8px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: var(--panel);
      box-shadow: 0 10px 24px rgba(0,0,0,.30);
      overflow:hidden;
      touch-action:none;
    }
    .task.dragging{
      cursor: grabbing;
      box-shadow: 0 16px 36px rgba(0,0,0,.45);
      background: rgba(255,220,120,0.9);
      border-color: rgba(255,220,120,1);
      transform: translateY(-2px);
      transition: box-shadow .08s ease, transform .08s ease, background .08s ease, border-color .08s ease;
      overflow: visible;
    }
    .task.resizing{ overflow: visible; }
    .task.dragging::before,
    .task.dragging::after,
    .task.resizing::before,
    .task.resizing::after{
      content:"";
      position:absolute;
      left:50%;
      width:100vw;
      transform: translateX(-50%);
      height:3px;
      background: linear-gradient(90deg, rgba(255,220,120,.1), rgba(255,220,120,.9), rgba(255,220,120,.1));
      box-shadow: 0 0 6px rgba(255,220,120,.8);
      pointer-events:none;
      z-index: 6;
    }
    .task.dragging::before,
    .task.resizing::before{ top:0; }
    .task.dragging::after,
    .task.resizing::after{ bottom:0; }
    .task .band{
      position:absolute;
      top:0; left:0;
      width:10px; height:100%;
      background: var(--accent);
      opacity:.95;
      z-index: 1;
    }

    /* ✅ #3: Urgent animation now becomes the CARD BACKGROUND (not border) */
    .task.urgent{
      background: radial-gradient(circle at 20% 20%, rgba(255,122,140,.5), transparent 40%),
                  rgba(50,2,10,.9);
      border-color: rgba(255,120,140,.7);
      box-shadow: 0 0 0 3px rgba(255,120,140,.6), 0 22px 46px rgba(255,78,106,.45);
      animation: urgentPulse 0.65s ease-in-out infinite, urgentGlow 1.2s ease-in-out infinite;
    }
    .task.urgent::after{
      content:"";
      position:absolute;
      inset:-10px;
      border-radius:18px;
      background:
        repeating-linear-gradient(45deg, rgba(255,78,106,.24), rgba(255,78,106,.24) 6px, transparent 6px, transparent 12px),
        radial-gradient(circle, rgba(255,78,106,.32), transparent 58%);
      filter: blur(6px);
      z-index:0;
      animation: urgentAura 0.9s ease-in-out infinite;
      pointer-events:none;
    }
    @keyframes urgentPulse{
      0%{ box-shadow: 0 0 0 3px rgba(255,78,106,.65), 0 28px 56px rgba(255,78,106,.42); transform: translateY(-2px) scale(1.01); }
      50%{ box-shadow: 0 0 0 14px rgba(255,78,106,.05), 0 12px 28px rgba(255,78,106,.2); transform: translateY(0) scale(1); }
      100%{ box-shadow: 0 0 0 3px rgba(255,78,106,.65), 0 28px 56px rgba(255,78,106,.42); transform: translateY(-2px) scale(1.01); }
    }
    @keyframes urgentGlow{
      0%,100%{ background: radial-gradient(circle at 20% 20%, rgba(255,122,140,.7), transparent 40%), rgba(55,4,12,.92); }
      50%{ background: radial-gradient(circle at 25% 25%, rgba(255,180,180,.75), transparent 46%), rgba(70,6,16,.96); }
    }
    @keyframes urgentAura{
      0%{ opacity:.9; transform: scale(0.96); }
      50%{ opacity:.35; transform: scale(1.08); }
      100%{ opacity:.9; transform: scale(0.96); }
    }

    .taskInner{
      position:relative;
      padding:10px 10px 10px 14px;
      display:flex;
      flex-direction:column;
      gap:8px;
      z-index: 2;
    }
    .task.done{
      filter: grayscale(.55);
      opacity: .6;
      background: rgba(16,18,26,.6);
      border-color: rgba(255,255,255,.06);
    }
    .task.done::before{
      content:"";
      position:absolute;
      inset:0;
      z-index:1;
      background-image: repeating-linear-gradient(135deg, rgba(255,255,255,.08) 0 8px, transparent 8px 16px);
      pointer-events:none;
      opacity:.25;
    }

    /* Buttons top-right, icon only */
    .taskTopRow{
      position:absolute;
      top:8px;
      left:10px;
      right:8px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      z-index: 3;
    }
    .taskTopRow .taskTypeChip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      box-shadow: var(--btnShadow);
      max-width: 60%;
      pointer-events:none;
    }
    .taskTopRow .taskActions{
      display:flex;
      gap:8px;
      margin-left:auto;
    }
    .taskTypeName{
      font-weight:850;
      font-size:12px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .taskTitle{
      font-weight:950;
      font-size:13px;
      line-height:1.2;
      width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      display:-webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      margin-top:42px; /* space under top row */
      padding-right: 0;
    }

    /* ✅ #6: customer directly below title, 70% brightness, no prefix */
    .taskCustomer{
      font-weight:900;
      font-size:12px;
      color: rgba(233,238,252,.70);
      opacity: 1;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      padding-right: 10px;
    }

    .taskMeta{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      align-items:center;
      color:var(--muted);
      font-size:12px;
    }
    .badge{
      display:inline-flex; align-items:center; gap:6px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color:var(--text);
      font-size:12px;
      white-space:nowrap;
      max-width: 100%;
    }
    .badge .dot{
      width:10px;height:10px;border-radius:50%;
      background: var(--accent);
      flex:0 0 auto;
    }
    .chips{display:flex; flex-wrap:wrap; gap:6px;}

    .resizeHandle{
      position:absolute;
      left:0; right:0;
      height:12px;
      z-index:4;
      cursor: ns-resize;
      touch-action:none;
    }
    .resizeHandle.top{top:-2px}
    .resizeHandle.bottom{bottom:-2px}
    .resizeGrip{
      position:absolute;
      left:50%;
      top:50%;
      width:34px;height:6px;
      transform:translate(-50%,-50%);
      border-radius:999px;
      background: rgba(255,255,255,.25);
      opacity:.65;
    }

    .ghostCreate{
      position:absolute;
      left:8px; right:8px;
      border-radius:14px;
      border:1px dashed rgba(78,161,255,.55);
      background: rgba(78,161,255,.12);
      pointer-events:none;
    }

    /* Month view */
    .month{height:100%;display:flex;flex-direction:column;overflow:hidden}
    .monthGrid{height:100%;overflow:auto;padding:12px}
    .monthHeaderRow{display:grid; grid-template-columns: repeat(7, 1fr);gap:10px;padding:0 12px 10px 12px;color:var(--muted);font-weight:800;font-size:12px;}
    .monthCells{display:grid; grid-template-columns: repeat(7, 1fr);gap:10px;padding: 0 12px 12px 12px;}
    .mCell{min-height: 120px;border-radius: 16px;border:1px solid rgba(255,255,255,.10);background: rgba(255,255,255,.03);padding:10px;display:flex; flex-direction:column; gap:8px;overflow:hidden;}
    .mCell.outside{opacity:.55;background: rgba(255,255,255,.02)}
    .mCell.today{border-color: rgba(78,161,255,.35);background: rgba(78,161,255,.08)}
    .mTop{display:flex;align-items:center;justify-content:space-between;gap:8px}
    .mDate{font-weight:900;display:flex;align-items:baseline;gap:8px}
    .mDate span{font-size:12px;color:var(--muted);font-weight:700}
    .mAdd{
      width:30px;height:30px;border-radius:11px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      box-shadow: var(--btnShadow);
      transition: box-shadow .12s ease, transform .12s ease;
    }
    .mAdd:active{box-shadow: var(--btnShadowDown); transform: translateY(1px);}
    .mAdd .ico{width:16px;height:16px}
    .mTasks{display:flex;flex-direction:column;gap:6px;overflow:auto;padding-right:4px}
    .mTasks::-webkit-scrollbar{width:8px}
    .mTasks::-webkit-scrollbar-thumb{background: rgba(255,255,255,.10); border-radius:20px}
    .mTaskPill{
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      padding:8px 10px;
      display:flex; gap:8px; align-items:center;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 0 8px 18px rgba(0,0,0,.22);
    }
    .mTaskPill .bar{width:6px;height: 16px;border-radius:999px;background: var(--accent);flex:0 0 auto}
    .mTaskPill .txt{font-weight:850;font-size:12px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .mTaskPill .tm{margin-left:auto;color:var(--muted);font-size:11px;white-space:nowrap}

    /* Modals */
    .modalBack{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:1000;
      padding: 14px;
    }
    .modalBack.show{display:flex}
    .modal{
      width:min(920px, 100%);
      max-height: 86vh;
      border-radius: 18px;
      background: rgba(17,21,33,.92);
      backdrop-filter: blur(12px);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .modalHeader{
      padding: 12px 14px;
      border-bottom:1px solid rgba(255,255,255,.08);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .modalHeader h3{margin:0;font-size:14px;font-weight:950;letter-spacing:.2px}
    .modalBody{
      overflow:auto;
      padding: 14px;
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .grid2{display:grid; grid-template-columns: 1fr 1fr; gap:12px}
    .grid3{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:12px}

    .field{
      display:flex; flex-direction:column; gap:6px;
      padding:10px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.03);
    }
    .field label{font-size:12px; color:var(--muted); font-weight:800}

    .field input, .field select, .field textarea{
      width:100%;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      color: var(--text);
      padding: 10px 10px;
      outline:none;
      box-shadow: var(--insetShadow);
    }
    .field textarea{min-height: 84px; resize: vertical}

    .modalFooter{
      padding: 12px 14px;
      border-top:1px solid rgba(255,255,255,.08);
      display:flex;
      gap:10px;
      justify-content:flex-end;
      align-items:center;
      flex-wrap:wrap;
    }
    .timerRow{
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
    }
    .timerDisplay{
      font-weight:900;
      font-size:18px;
      letter-spacing:0.6px;
      padding:10px 14px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      min-width:140px;
      text-align:center;
      box-shadow: var(--insetShadow);
    }
    .subtleNote{font-size:12px;color:var(--muted);margin-top:6px;}
    .inlineRow{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .help{font-size:12px; color:var(--muted); line-height:1.35}
    .muted{color:var(--muted)}

    .list{display:flex;flex-direction:column;gap:8px}
    .itemRow{
      display:flex; gap:8px; align-items:center;
      padding:10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
    }
    .swatch{
      width:14px;height:14px;border-radius:50%;
      background: var(--accent);
      border:1px solid rgba(255,255,255,.18);
    }
    .itemRow input[type="text"]{flex:1}
    .itemRow input[type="color"]{width:40px;height:34px;border:none;background: transparent; padding:0}

    .toastWrap{
      position:fixed;
      top: calc(env(safe-area-inset-top, 0px) + 12px);
      right: 12px;
      z-index: 2000;
      display:flex;
      flex-direction:column;
      gap:8px;
      pointer-events:none;
    }
    .toast{
      pointer-events:none;
      width: min(360px, calc(100vw - 24px));
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(17,21,33,.92);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      gap:10px;
      align-items:flex-start;
      padding: 10px 12px;
    }
    .toast .bar{width:6px; align-self:stretch; border-radius:999px;background: var(--accent);opacity:.9}
    .toast .tTitle{font-weight:900; font-size:13px; margin-bottom:2px}
    .toast .tMsg{color:var(--muted); font-size:12px; line-height:1.35}

    /* Card buttons (icon-only now) */
    .cardBtn{
      width:34px;
      height:30px;
      padding:0;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      color: var(--text);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      box-shadow: var(--btnShadow);
      transform: translateY(0);
      transition: box-shadow .12s ease, transform .12s ease, background .12s ease;
    }
    .cardBtn:hover{ background: rgba(255,255,255,.06); }
    .cardBtn:active{ box-shadow: var(--btnShadowDown); transform: translateY(1px); }
    .cardBtn .ico{ width:16px; height:16px; background: currentColor; mask-size: contain; mask-repeat:no-repeat; mask-position:center; -webkit-mask-size:contain; -webkit-mask-repeat:no-repeat; -webkit-mask-position:center; }
    .cardBtn.edit{ border-color: rgba(78,161,255,.30); background: rgba(78,161,255,.10); }
    .cardBtn.delete{ border-color: rgba(255,78,106,.32); background: rgba(255,78,106,.12); color:#ffd3db; }
    .cardBtn.done{ border-color: rgba(46,229,157,.4); background: rgba(46,229,157,.14); color:#c7ffea; }
    .trackIndicator{
      width:30px; height:30px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      color: var(--text);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      position:relative;
      box-shadow: var(--btnShadow);
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .trackIndicator .ico{width:14px;height:14px; background: currentColor; mask-size:contain; mask-repeat:no-repeat; mask-position:center; -webkit-mask-size:contain; -webkit-mask-repeat:no-repeat; -webkit-mask-position:center;}
    .trackIndicator.running{
      border-color: rgba(78,161,255,.45);
      color: #b8d8ff;
    }
    .trackIndicator.running::after{
      content:"";
      position:absolute;
      inset:-4px;
      border-radius:50%;
      border:2px solid transparent;
      border-top-color: rgba(78,161,255,.95);
      border-right-color: rgba(78,161,255,.55);
      border-left-color: rgba(78,161,255,.30);
      animation: spinClock 1.2s linear infinite;
      box-shadow: 0 0 0 1px rgba(78,161,255,.12);
    }
    @keyframes spinClock{
      from{ transform: rotate(0deg); }
      to{ transform: rotate(360deg); }
    }

    /* Drag ghost for sidebar */
    .dragGhost{
      position:fixed;
      z-index:5000;
      pointer-events:none;
      width:min(280px, 70vw);
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(17,21,33,.92);
      box-shadow: 0 18px 40px rgba(0,0,0,.45);
      overflow:hidden;
      opacity:.95;
    }
    .dragGhost .band{width:10px; height:100%; position:absolute; left:0; top:0; opacity:.95}
    .dragGhost .inner{padding:10px 10px 10px 14px; display:flex; flex-direction:column; gap:6px}
    .dragGhost .t{font-weight:950;font-size:13px; line-height:1.2; overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .dragGhost .c{font-weight:900;font-size:12px; color: rgba(233,238,252,.70); overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .dragGhost .m{color:var(--muted); font-size:12px; display:flex; gap:6px; flex-wrap:wrap}

    @media (max-width: 920px){
      :root{ --timeColW: 62px; --sideW: 300px; }
      .brand{min-width:unset}
      .brandSub{display:none}
      .pill{display:none}
      .dayHead{flex-basis: 188px; min-width:188px}
      .dayCol{flex-basis: 188px; min-width:188px}
      .grid2, .grid3{grid-template-columns:1fr}
    }
    @media (max-width: 720px){
      :root{ --sideW: 86vw; }
      .sidePanel{
        position:absolute;
        right:0;
        top:0;
        z-index:40;
        box-shadow: -20px 0 60px rgba(0,0,0,.35);
      }
    }
  </style>
</head>

<body>
  <div class="appHeader">
    <div class="brand">
      <div class="brandBadge"></div>
      <div>
        <div class="brandTitle">Schedule Board</div>
        <div class="brandSub">15-min slots • Drag-to-create • Drag-to-move</div>
      </div>
    </div>

    <div class="headerLeft">
      <button class="btn icon" id="prevDayBtn" title="Previous day"><span class="ico chevL"></span></button>
      <button class="btn icon" id="prevBtn" title="Previous week"><span class="ico chevLL"></span></button>
      <button class="btn icon" id="todayBtn" title="Today"><span class="ico today"></span></button>
      <button class="btn icon" id="nextBtn" title="Next week"><span class="ico chevRR"></span></button>
      <button class="btn icon" id="nextDayBtn" title="Next day"><span class="ico chevR"></span></button>

          <div class="pill" id="rangePill">
            <div>
              <div class="pillTitle" id="rangeTitle">—</div>
              <div class="pillMeta" id="rangeMeta">—</div>
            </div>
          </div>

      <select class="select" id="viewSelect" aria-label="View">
        <option value="day">Day</option>
        <option value="workweek">Mon–Fri</option>
        <option value="week">Week (7 days)</option>
        <option value="2week">2 weeks</option>
        <option value="custom">Custom days</option>
        <option value="month">Month</option>
      </select>

      <div class="seg" id="customDaysSeg" style="display:none;">
        <span class="muted" style="font-size:12px; font-weight:800;">Days</span>
        <input id="customDaysInput" type="range" min="1" max="21" value="7" style="width:120px">
        <span id="customDaysVal" style="font-weight:900;">7</span>
      </div>
    </div>

      <div class="headerRight">
        <div class="pill" id="userPill">
          <div class="pillTitle">User</div>
          <div class="pillMeta" id="currentUser">Tristan</div>
        </div>
        <button class="btn primary" id="addTaskBtn"><span class="ico plus"></span> Add Task</button>
        <button class="btn icon" id="settingsBtn" title="Settings"><span class="ico cog"></span></button>
      </div>
  </div>

  <div class="appBody">
    <div class="layout" id="layout">
      <div class="mainArea">
        <div class="boardWrap" id="boardWrap"></div>
      </div>

      <!-- Unassigned tasks panel -->
      <aside class="sidePanel hidden" id="sidePanel">
        <div class="sideHeader">
          <div class="sideHeaderTop">
            <div class="sideTitle">
              Unassigned
              <span class="countBadge" id="unassignedCount">0</span>
            </div>
            <button class="btn icon" id="sideCloseBtn" title="Hide"><span class="ico chevR"></span></button>
          </div>
          <div class="sideControls">
            <input id="unassignedSearch" type="text" placeholder="Filter…" />
            <select id="unassignedSort" title="Sort">
              <option value="new">Newest</option>
              <option value="old">Oldest</option>
              <option value="az">Title A–Z</option>
              <option value="za">Title Z–A</option>
              <option value="priority">Priority</option>
              <option value="type">Type</option>
            </select>
          </div>
        </div>
        <div class="dropHint" id="sideDropHint">
          Drag tasks here to <b>remove time</b> (unassign). Drag from here onto the board to schedule.
        </div>
        <div class="sideList" id="unassignedList"></div>
      </aside>
    </div>
  </div>

  <!-- Task Modal -->
  <div class="modalBack" id="taskModalBack">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="taskModalTitle">
      <div class="modalHeader">
        <h3 id="taskModalTitle">Task</h3>
        <button class="btn icon" id="taskModalClose" title="Close">✕</button>
      </div>
      <div class="modalBody">
        <div class="grid2">
          <div class="field">
            <label>Task name</label>
            <input id="fTitle" type="text" placeholder="e.g. Install ACM sign - Springwood" />
          </div>
          <div class="field">
            <label>Task type</label>
            <div class="inlineRow">
              <select id="fType" style="flex:1"></select>
              <input id="fNewType" type="text" placeholder="Add type (e.g. Painting)" style="flex:1" />
              <button class="btn" id="addTypeOnFlyBtn" title="Add task type">Add</button>
            </div>
            <div class="help">Task type controls the left color band. You can add a new type on the fly.</div>
          </div>
        </div>

        <div class="grid2">
          <div class="field">
            <label>Job #</label>
            <input id="fJob" type="text" placeholder="Optional" />
          </div>
          <div class="field">
            <label>Customer name</label>
            <input id="fCustomer" type="text" placeholder="e.g. John Smith / ACME Pty Ltd" />
          </div>
        </div>

        <div class="grid3">
          <div class="field">
            <label>Contact name</label>
            <input id="fContactName" type="text" placeholder="Customer contact" />
          </div>
          <div class="field">
            <label>Contact phone</label>
            <input id="fContactPhone" type="text" placeholder="Phone" />
          </div>
          <div class="field">
            <label>Customer email</label>
            <input id="fCustomerEmail" type="email" placeholder="Email" />
          </div>
        </div>

        <div class="field">
          <label>Assigned people</label>
          <div id="peoplePick" class="chips"></div>
          <div class="help">Tap chips to toggle staff. Each staff chip has its own color.</div>
        </div>

        <div class="field">
          <label>Scheduling</label>
          <div class="inlineRow" style="justify-content:space-between;">
            <div class="help">If <b>Unassigned</b> is enabled, this task will appear in the right panel with no time.</div>
            <label class="help" style="display:flex;align-items:center;gap:8px;cursor:pointer;">
              <input id="fUnassigned" type="checkbox" />
              Unassigned (no time)
            </label>
          </div>
        </div>

        <div class="grid2">
          <div class="field">
            <label>Start date</label>
            <input id="fStartDate" type="date" />
          </div>
          <div class="field">
            <label>Start time</label>
            <input id="fStartTime" type="time" step="900" />
          </div>
        </div>

        <div class="grid2">
        <div class="field">
          <label>End date</label>
          <input id="fEndDate" type="date" />
        </div>
        <div class="field">
          <label>End time</label>
          <input id="fEndTime" type="time" step="900" />
        </div>
      </div>

        <div class="field">
          <label>Promised install date</label>
          <input id="fPromisedDate" type="date" />
          <div class="subtleNote" id="promisedBy">Saved by: —</div>
        </div>

        <div class="grid2">
          <div class="field">
            <label>Flags</label>
            <div class="inlineRow">
              <select id="flagSelect" style="flex:1"></select>
              <button class="btn icon" id="addFlagPreset" title="Add flag"><span class="ico plus"></span></button>
            </div>
            <div class="inlineRow">
              <input id="fFlagTokens" type="text" placeholder="e.g. payment needed, not confirmed" style="flex:1" />
              <button class="btn" id="addFlagCustom" title="Add custom flag"><span class="ico plusCircle"></span> Add</button>
            </div>
            <div class="help">Pick a preset or add a custom flag. Comma-separated list is saved with the task.</div>
          </div>
          <div class="field">
            <label>Access equipment flags</label>
            <div class="inlineRow">
              <select id="accessSelect" style="flex:1"></select>
              <button class="btn icon" id="addAccessPreset" title="Add access flag"><span class="ico plus"></span></button>
            </div>
            <div class="inlineRow">
              <input id="fAccessTokens" type="text" placeholder="e.g. spider boom, scissor, trestles" style="flex:1" />
              <button class="btn" id="addAccessCustom" title="Add custom access flag"><span class="ico plusCircle"></span> Add</button>
            </div>
            <div class="help">Pick a preset or add custom equipment notes; they stay in the task details.</div>
          </div>
        </div>

        <div class="field">
          <label>Job time tracking</label>
          <div class="timerRow">
            <div class="timerDisplay" id="timerDisplay">00:00:00</div>
            <div class="inlineRow">
              <button class="btn primary" id="timerStartBtn" type="button"><span class="ico play" aria-hidden="true"></span> Start</button>
              <button class="btn" id="timerStopBtn" type="button" disabled><span class="ico stop" aria-hidden="true"></span> Stop</button>
            </div>
          </div>
        </div>

        <div class="grid3">
          <div class="field">
            <label>Status</label>
            <select id="fStatus">
              <option value="Planned">Planned</option>
              <option value="In progress">In progress</option>
              <option value="Done">Done</option>
              <option value="Blocked">Blocked</option>
            </select>
          </div>
          <div class="field">
            <label>Priority</label>
            <select id="fPriority">
              <option value="Normal">Normal</option>
              <option value="High">High</option>
              <option value="Urgent">Urgent</option>
              <option value="Low">Low</option>
            </select>
          </div>
          <div class="field">
            <label>Location</label>
            <input id="fLocation" type="text" placeholder="Optional (site address / suburb)" />
          </div>
        </div>

        <div class="field">
          <label>Notes</label>
          <textarea id="fNotes" placeholder="Notes..."></textarea>
        </div>

        <div class="help">
          <b>Quick use:</b> Drag on an empty day column to create a task (1 hour default if you just click).
          Drag tasks to move. Resize via handles. Times snap to 15-minute slots. Tasks can span days using Start/End date.
        </div>
      </div>
      <div class="modalFooter">
        <button class="btn danger" id="deleteTaskBtn" style="margin-right:auto; display:none;">
          <span class="ico trash"></span> Delete
        </button>
        <button class="btn" id="taskModalCancel">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="modalBack" id="settingsModalBack">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
      <div class="modalHeader">
        <h3 id="settingsTitle">Settings</h3>
        <button class="btn icon" id="settingsClose" title="Close">✕</button>
      </div>
      <div class="modalBody">
        <div class="grid3">
          <div class="field">
            <label>Working hours start</label>
            <input id="sStartHour" type="number" min="0" max="23" step="1" />
            <div class="help">Hour in 24h time (e.g. 6 = 6am).</div>
          </div>
          <div class="field">
            <label>Working hours end</label>
            <input id="sEndHour" type="number" min="1" max="24" step="1" />
            <div class="help">Hour in 24h time (e.g. 18 = 6pm).</div>
          </div>
          <div class="field">
            <label>Time format</label>
            <select id="sTimeFormat">
              <option value="12">AM/PM</option>
              <option value="24">24-hour</option>
            </select>
            <div class="help">Controls the left-side time labels + task time badges.</div>
          </div>
        </div>

        <div class="field">
          <label>Unassigned panel</label>
          <div class="inlineRow" style="justify-content:space-between;">
            <div class="help">Show the right-side panel for tasks with no time set.</div>
            <label class="help" style="display:flex;align-items:center;gap:8px;cursor:pointer;">
              <input id="sShowUnassigned" type="checkbox" />
              Enabled
            </label>
          </div>
        </div>

        <div class="field">
          <label>Highlight today</label>
          <div class="inlineRow" style="justify-content:space-between;">
            <div class="help">Make the current day twice as wide in timeline view.</div>
            <label class="help" style="display:flex;align-items:center;gap:8px;cursor:pointer;">
              <input id="sWideToday" type="checkbox" />
              Double width for today
            </label>
          </div>
        </div>

        <div class="field">
          <label>Staff (name + chip color)</label>
          <div class="list" id="staffList"></div>
          <div class="inlineRow">
            <input id="newStaffName" type="text" placeholder="Add staff name" style="flex:1" />
            <input id="newStaffColor" type="color" value="#4ea1ff" />
            <button class="btn" id="addStaffBtn2">Add Staff</button>
          </div>
        </div>

        <div class="field">
          <label>Task types (name + band color)</label>
          <div class="list" id="typeList"></div>
        </div>

        <div class="field">
          <label>Data</label>
          <div class="inlineRow">
            <button class="btn danger" id="resetDataBtn">Reset local data</button>
            <span class="help">This wipes tasks + settings in localStorage.</span>
          </div>
        </div>
      </div>
      <div class="modalFooter">
        <button class="btn" id="settingsCancel">Close</button>
        <button class="btn primary" id="settingsSave">Save</button>
      </div>
    </div>
  </div>

  <div class="toastWrap" id="toastWrap"></div>

  <script>
  (() => {
    'use strict';

    window.addEventListener('DOMContentLoaded', () => {

      const LS_KEY = "schedule_board_v1";
      const SLOT_MIN = 15;
      const SLOT_MS = SLOT_MIN * 60 * 1000;
      const CURRENT_USER = "Tristan";

      const FIREBASE_CONFIG = {
        apiKey: "AIzaSyDQFoHRttdQVuFnti1cpd1D_5OTCNvGvEQ",
        authDomain: "signscheduler-f5e80.firebaseapp.com",
        databaseURL: "https://signscheduler-f5e80-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "signscheduler-f5e80",
        storageBucket: "signscheduler-f5e80.firebasestorage.app",
        messagingSenderId: "536047819614",
        appId: "1:536047819614:web:cfed13e1a9e62bc4a60dcf",
        measurementId: "G-W885N8J421"
      };
      const FIRESTORE_TASKS_COLLECTION = "scheduleBoardTasks";
      const FIRESTORE_CONFIG_COLLECTION = "scheduleBoardConfig";
      const FIRESTORE_CONFIG_DOC = "shared";
      const FIREBASE_CONFIG_VALID = Object.values(FIREBASE_CONFIG).every(v => typeof v === "string" && v && !v.includes("<YOUR_"));
      let firestoreDb = null;
      let unsubscribeTasks = null;
      let unsubscribeConfig = null;
      let firestoreReady = false;
      let applyingRemoteSnapshot = false;
      let applyingRemoteConfig = false;
      let bootstrappedFromLocal = false;
      const pendingFirestoreOps = [];
      let pendingConfigSync = false;

      const $ = (sel, root=document) => root.querySelector(sel);
      const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

      let nowLineTimer = null;

      // ✅ #4 scroll preservation (no jumps after render)
      let lastScroll = {
        timeline: { x:0, y:0 },
        month: { y:0 }
      };

      const toastWrap = $("#toastWrap");
      function escapeHtml(s){
        return (s ?? "").toString()
          .replaceAll("&","&amp;")
          .replaceAll("<","&lt;")
          .replaceAll(">","&gt;")
          .replaceAll('"',"&quot;")
          .replaceAll("'","&#039;");
      }
      function toast(title, msg, color="var(--accent)", ms=2200){
        const el = document.createElement("div");
        el.className = "toast";
        el.innerHTML = `
          <div class="bar" style="background:${color}"></div>
          <div>
            <div class="tTitle">${escapeHtml(title)}</div>
            <div class="tMsg">${escapeHtml(msg)}</div>
          </div>
        `;
        toastWrap.appendChild(el);
        setTimeout(()=>{ el.style.opacity="0"; el.style.transition="opacity .2s"; }, Math.max(0, ms-180));
        setTimeout(()=>{ el.remove(); }, ms);
      }

      function pad2(n){ return (n<10?"0":"")+n; }
      function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
      function startOfDay(d){ const x=new Date(d); x.setHours(0,0,0,0); return x; }
      function addDays(d,n){ const x=new Date(d); x.setDate(x.getDate()+n); return x; }
      function sameDay(a,b){ return a.getFullYear()===b.getFullYear() && a.getMonth()===b.getMonth() && a.getDate()===b.getDate(); }
      function isoDate(d){ const x=new Date(d); return `${x.getFullYear()}-${pad2(x.getMonth()+1)}-${pad2(x.getDate())}`; }
      function parseDateInput(v){ const [y,m,dd]=v.split("-").map(Number); return new Date(y, m-1, dd, 0,0,0,0); }
      function parseTimeInput(v){ const [h,m]=v.split(":").map(Number); return {h, m}; }
      function snapToSlotMs(ms){ return Math.round(ms / SLOT_MS) * SLOT_MS; }
      function minutesBetween(a,b){ return Math.round((b-a)/60000); }
      function fmtMonthTitle(d){ return d.toLocaleDateString(undefined, { month:"long", year:"numeric" }); }
      function formatDurationHMS(ms){
        const totalSec = Math.max(0, Math.floor(ms / 1000));
        const h = Math.floor(totalSec / 3600);
        const m = Math.floor((totalSec % 3600) / 60);
        const s = totalSec % 60;
        return `${pad2(h)}:${pad2(m)}:${pad2(s)}`;
      }
      function parseTokens(str){
        return (str||"").split(",").map(t=>t.trim()).filter(Boolean);
      }
      function uniqTokens(arr){
        return Array.from(new Set((arr||[]).map(s=>s.trim()).filter(Boolean)));
      }
      function enqueueFirestoreOp(fn){
        pendingFirestoreOps.push(fn);
        flushFirestoreQueue();
      }
      function flushFirestoreQueue(){
        if(!firestoreReady) return;
        while(pendingFirestoreOps.length){
          const op = pendingFirestoreOps.shift();
          try{
            op();
          }catch(err){
            console.error("Firestore operation failed", err);
          }
        }
      }
      function tsToIso(v){
        try{
          if(!v) return null;
          if(typeof v === "string"){
            const d = new Date(v);
            return Number.isNaN(d.getTime()) ? null : d.toISOString();
          }
          if(v.toDate){
            const d = v.toDate();
            return Number.isNaN(d.getTime()) ? null : d.toISOString();
          }
        }catch(err){
          console.warn("Failed to parse timestamp", err);
        }
        return null;
      }
      function numberOrNull(v){
        if(v == null) return null;
        if(typeof v === "number" && Number.isFinite(v)) return v;
        if(v.toMillis){
          const n = v.toMillis();
          return Number.isFinite(n) ? n : null;
        }
        return null;
      }
      function normalizeType(t){
        if(!t || typeof t !== "object") return null;
        return {
          id: (typeof t.id === "string" && t.id) ? t.id : uid(),
          name: (t.name || "Type").toString(),
          color: (t.color || randomNiceColor())
        };
      }
      function normalizeStaff(s){
        if(!s || typeof s !== "object") return null;
        return {
          id: (typeof s.id === "string" && s.id) ? s.id : uid(),
          name: (s.name || "Staff").toString(),
          color: (s.color || "#4ea1ff")
        };
      }
      function syncConfigToFirestore(){
        if(!FIREBASE_CONFIG_VALID || !window.firebase) return;
        if(applyingRemoteConfig){
          pendingConfigSync = true;
          return;
        }
        enqueueFirestoreOp(()=>{
          if(!firestoreReady || !firestoreDb) return;
          pendingConfigSync = false;
          firestoreDb
            .collection(FIRESTORE_CONFIG_COLLECTION)
            .doc(FIRESTORE_CONFIG_DOC)
            .set({
              types: state.types,
              staff: state.staff,
              updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
              updatedBy: CURRENT_USER
            }, { merge: true })
            .catch(err => console.error("Failed to sync config to Firestore", err));
        });
      }
      function subscribeToConfig(){
        if(!firestoreDb) return;
        if(unsubscribeConfig) unsubscribeConfig();
        unsubscribeConfig = firestoreDb
          .collection(FIRESTORE_CONFIG_COLLECTION)
          .doc(FIRESTORE_CONFIG_DOC)
          .onSnapshot(snapshot=>{
            if(!snapshot || !snapshot.exists){
              syncConfigToFirestore();
              return;
            }
            const data = snapshot.data() || {};
            const incomingTypes = Array.isArray(data.types) ? data.types.map(normalizeType).filter(Boolean) : [];
            const incomingStaff = Array.isArray(data.staff) ? data.staff.map(normalizeStaff).filter(Boolean) : [];
            if(!incomingTypes.length && !incomingStaff.length){
              syncConfigToFirestore();
              return;
            }
            applyingRemoteConfig = true;
            if(incomingTypes.length) state.types = incomingTypes;
            if(incomingStaff.length) state.staff = incomingStaff;
            saveState();
            render();
            applyingRemoteConfig = false;
            if(pendingConfigSync){
              syncConfigToFirestore();
            }
          }, err=>{
            console.error("Firestore config live sync error", err);
          });
      }
      function touchConfig(){
        saveState();
        syncConfigToFirestore();
      }
      function normalizeTaskFromFirestore(id, data){
        const safe = data || {};
        return {
          id,
          title: safe.title || "New task",
          typeId: safe.typeId || (state.types[0]?.id ?? ""),
          people: Array.isArray(safe.people) ? safe.people : [],
          start: tsToIso(safe.start),
          end: tsToIso(safe.end),
          notes: safe.notes || "",
          location: safe.location || "",
          status: safe.status || "Planned",
          priority: safe.priority || "Normal",
          jobNo: safe.jobNo || "",
          customer: safe.customer || "",
          contactName: safe.contactName || "",
          contactPhone: safe.contactPhone || "",
          customerEmail: safe.customerEmail || "",
          trackedMs: typeof safe.trackedMs === "number" ? safe.trackedMs : 0,
          timerStartedAt: numberOrNull(safe.timerStartedAt),
          promisedInstall: tsToIso(safe.promisedInstall)?.slice(0,10) || (typeof safe.promisedInstall === "string" ? safe.promisedInstall : ""),
          promisedBy: safe.promisedBy || "",
          flags: Array.isArray(safe.flags) ? safe.flags : parseTokens(safe.flags || ""),
          accessFlags: Array.isArray(safe.accessFlags) ? safe.accessFlags : parseTokens(safe.accessFlags || "")
        };
      }
      function syncTaskToFirestore(task){
        if(!FIREBASE_CONFIG_VALID || applyingRemoteSnapshot || !window.firebase) return;
        enqueueFirestoreOp(()=>{
          if(!firestoreReady || !firestoreDb) return;
          const {id, ...payload} = task;
          firestoreDb
            .collection(FIRESTORE_TASKS_COLLECTION)
            .doc(id)
            .set({
              ...payload,
              updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
              updatedBy: CURRENT_USER
            }, { merge: true })
            .catch(err => console.error("Failed to sync task to Firestore", err));
        });
      }
      function deleteTaskFromFirestore(taskId){
        if(!FIREBASE_CONFIG_VALID || applyingRemoteSnapshot || !window.firebase) return;
        enqueueFirestoreOp(()=>{
          if(!firestoreReady || !firestoreDb) return;
          firestoreDb
            .collection(FIRESTORE_TASKS_COLLECTION)
            .doc(taskId)
            .delete()
            .catch(err => console.error("Failed to delete task from Firestore", err));
        });
      }
      async function initFirestoreSync(){
        if(!FIREBASE_CONFIG_VALID || !window.firebase){
          console.info("Firebase config missing; running in local-only mode.");
          return;
        }
        try{
          firebase.initializeApp(FIREBASE_CONFIG);
          firestoreDb = firebase.firestore();
          try{
            await firestoreDb.enablePersistence({ synchronizeTabs:true });
          }catch(err){
            console.warn("Firestore offline persistence not enabled", err);
          }
          firestoreReady = true;
          flushFirestoreQueue();
          subscribeToConfig();
          subscribeToTaskChanges();
        }catch(err){
          console.error("Failed to initialize Firebase", err);
        }
      }
      function subscribeToTaskChanges(){
        if(!firestoreDb) return;
        if(unsubscribeTasks) unsubscribeTasks();
        unsubscribeTasks = firestoreDb
          .collection(FIRESTORE_TASKS_COLLECTION)
          .onSnapshot(snapshot=>{
            if(!snapshot) return;
            if(snapshot.empty && state.tasks.length && !bootstrappedFromLocal){
              state.tasks.forEach(syncTaskToFirestore);
              bootstrappedFromLocal = true;
              return;
            }
            const remoteTasks = snapshot.docs.map(doc=> normalizeTaskFromFirestore(doc.id, doc.data()));
            applyingRemoteSnapshot = true;
            state.tasks = remoteTasks;
            saveState();
            render();
            applyingRemoteSnapshot = false;
          }, err=>{
            console.error("Firestore live sync error", err);
          });
      }

      function formatTime(dateObj){
        const d = new Date(dateObj);
        if(state.settings.timeFormat === "24"){
          return `${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
        }
        let h = d.getHours();
        const m = d.getMinutes();
        const ampm = h >= 12 ? "pm" : "am";
        h = h % 12; if(h === 0) h = 12;
        return `${h}:${pad2(m)}${ampm}`;
      }
      function formatHourLabel(h24){
        if(state.settings.timeFormat === "24"){
          return `${pad2(h24%24)}:00`;
        }
        const ampm = h24 >= 12 ? "pm" : "am";
        let h = h24 % 12; if(h === 0) h = 12;
        return `${h}${ampm}`;
      }

      function getMonday(d){
        const x = startOfDay(d);
        const day = x.getDay(); // 0=Sun
        const diff = (day === 0 ? -6 : 1 - day);
        return addDays(x, diff);
      }
      function uid(){ return Math.random().toString(16).slice(2) + Date.now().toString(16); }

      const defaultState = () => ({
        settings: {
          startHour: 6,
          endHour: 18,
          timeFormat: "12",
          showUnassignedPanel: true,
          wideToday: false
        },
        flagOptions: ["Payment needed", "Not confirmed", "Awaiting artwork"],
        accessOptions: ["Spider boom", "Scissor", "Trestles", "Ladders"],
        staff: [
          { id: uid(), name: "Tristan", color: "#4ea1ff" },
          { id: uid(), name: "Aidan", color: "#ffb020" },
          { id: uid(), name: "Daniel", color: "#7c5cff" },
          { id: uid(), name: "Jake", color: "#2ee59d" },
          { id: uid(), name: "Patrick", color: "#e86dff" },
          { id: uid(), name: "Peter", color: "#ff9f4e" },
          { id: uid(), name: "Pearl", color: "#5cd1b2" },
          { id: uid(), name: "Leandri", color: "#6bdcff" },
          { id: uid(), name: "Darren", color: "#ff5c8a" },
        ],
        types: [
          { id: uid(), name: "Install", color: "#4ea1ff" },
          { id: uid(), name: "Design",  color: "#7c5cff" },
          { id: uid(), name: "Print",   color: "#2ee59d" },
          { id: uid(), name: "Site Measure", color: "#ffb020" },
          { id: uid(), name: "Production", color: "#5cd1b2" },
          { id: uid(), name: "Paint", color: "#e86dff" },
          { id: uid(), name: "Weld", color: "#ff9f4e" },
          { id: uid(), name: "Laser", color: "#ff5c8a" },
          { id: uid(), name: "Router", color: "#6bdcff" },
          { id: uid(), name: "Other",   color: "#9aa6c3" },
        ],
        tasks: [],
        ui: { view: "workweek", anchorDate: isoDate(new Date()), customDays: 7 }
      });

      function loadState(){
        try{
          const raw = localStorage.getItem(LS_KEY);
          if(!raw) return null;
          const st = JSON.parse(raw);
          if(!st.settings || !st.staff || !st.types || !st.tasks || !st.ui) return null;
          if(!st.settings.timeFormat) st.settings.timeFormat = "12";
          if(typeof st.settings.showUnassignedPanel !== "boolean") st.settings.showUnassignedPanel = true;
          if(typeof st.settings.wideToday !== "boolean") st.settings.wideToday = false;
          if(!Array.isArray(st.flagOptions)) st.flagOptions = ["Payment needed", "Not confirmed", "Awaiting artwork"];
          if(!Array.isArray(st.accessOptions)) st.accessOptions = ["Spider boom", "Scissor", "Trestles", "Ladders"];
          st.tasks.forEach(t=>{
            if(typeof t.trackedMs !== "number") t.trackedMs = 0;
            if(t.timerStartedAt && typeof t.timerStartedAt !== "number"){
              const asNum = Number(t.timerStartedAt);
              t.timerStartedAt = Number.isFinite(asNum) ? asNum : null;
            }
            if(!Array.isArray(t.flags)) t.flags = parseTokens(t.flags || "");
            if(!Array.isArray(t.accessFlags)) t.accessFlags = parseTokens(t.accessFlags || "");
            if(typeof t.promisedInstall !== "string") t.promisedInstall = "";
            if(typeof t.promisedBy !== "string") t.promisedBy = "";
            if(typeof t.contactName !== "string") t.contactName = "";
            if(typeof t.contactPhone !== "string") t.contactPhone = "";
            if(typeof t.customerEmail !== "string") t.customerEmail = "";
          });
          return st;
        }catch(e){
          console.warn("Failed to load state", e);
          return null;
        }
      }

      let state = loadState() || defaultState();

      function saveState(){ localStorage.setItem(LS_KEY, JSON.stringify(state)); }

      function isUnassigned(task){
        return !task.start || !task.end; // ✅ supports “no time set”
      }

      function addTask(taskLike, {silent=false}={}){
        const t = {
          id: uid(),
          title: taskLike.title || "New task",
          typeId: taskLike.typeId || (state.types[0]?.id ?? ""),
          people: Array.isArray(taskLike.people) ? taskLike.people : [],
          start: taskLike.start ?? null,
          end: taskLike.end ?? null,
          notes: taskLike.notes || "",
          location: taskLike.location || "",
          status: taskLike.status || "Planned",
          priority: taskLike.priority || "Normal",
          jobNo: taskLike.jobNo || "",
          customer: taskLike.customer || "",
          contactName: taskLike.contactName || "",
          contactPhone: taskLike.contactPhone || "",
          customerEmail: taskLike.customerEmail || "",
          trackedMs: taskLike.trackedMs ?? 0,
          timerStartedAt: taskLike.timerStartedAt ?? null,
          promisedInstall: taskLike.promisedInstall ?? "",
          promisedBy: taskLike.promisedBy ?? "",
          flags: uniqTokens(Array.isArray(taskLike.flags) ? taskLike.flags : parseTokens(taskLike.flags || "")),
          accessFlags: uniqTokens(Array.isArray(taskLike.accessFlags) ? taskLike.accessFlags : parseTokens(taskLike.accessFlags || ""))
        };
        state.tasks.push(t);
        syncTaskToFirestore(t);
        if(!silent) toast("Task added", t.title, "var(--accent)");
        saveState();
        render();
        return t.id;
      }

      function updateTask(taskId, patch, {silent=false}={}){
        const i = state.tasks.findIndex(t=>t.id===taskId);
        if(i<0) return;
        state.tasks[i] = {...state.tasks[i], ...patch};
        syncTaskToFirestore(state.tasks[i]);
        if(!silent) toast("Task saved", state.tasks[i].title, "var(--accent)");
        saveState();
        render();
      }

      function deleteTask(taskId){
        const i = state.tasks.findIndex(t=>t.id===taskId);
        if(i<0) return;
        const title = state.tasks[i].title || "Task";
        state.tasks.splice(i,1);
        deleteTaskFromFirestore(taskId);
        saveState();
        toast("Deleted", title, "var(--danger)");
        render();
      }

      function seedIfEmpty(){
        if(state.tasks.length) return;

        const anchor = parseDateInput(state.ui.anchorDate);
        const mon = getMonday(anchor);
        const typeInstall = state.types.find(t=>t.name==="Install")?.id || state.types[0].id;
        const typeDesign = state.types.find(t=>t.name==="Design")?.id || state.types[1].id;
        const typePrint  = state.types.find(t=>t.name==="Print")?.id || state.types[2].id;

        const staffIds = state.staff.map(s=>s.id);
        const mk = (dayOffset, sh, sm, eh, em, title, typeId, people, extra={}) => {
          const d = addDays(mon, dayOffset);
          const start = new Date(d); start.setHours(sh, sm, 0, 0);
          const end = new Date(d); end.setHours(eh, em, 0, 0);
          addTask({
            title, typeId, people,
            start: start.toISOString(),
            end: end.toISOString(),
            notes: extra.notes || "",
            location: extra.location || "",
            status: extra.status || "Planned",
            priority: extra.priority || "Normal",
            jobNo: extra.jobNo || "",
            customer: extra.customer || ""
          }, {silent:true});
        };

        mk(0, 8, 0, 11, 0, "Install ACM fascia - Springwood", typeInstall, [staffIds[0], staffIds[1]], {
          customer:"ACME Pty Ltd",
          location: "Springwood",
          jobNo:"SR-10231",
          notes:"Bring ladder + rivet gun. Confirm access with client.",
          priority:"High"
        });

        mk(0, 12, 0, 14, 30, "Design proof - Window graphics", typeDesign, [staffIds[2]], {
          customer:"John Smith",
          status:"In progress",
          notes:"Waiting on customer logo file. Send reminder if not received by 2pm."
        });

        mk(1, 9, 0, 12, 0, "Print + laminate - 3x banners", typePrint, [staffIds[3], staffIds[2]], {
          customer:"Pelleton Renewables",
          notes:"Check artwork bleed and grommet positions."
        });

        // Spans days
        const d2 = addDays(mon, 2);
        const s = new Date(d2); s.setHours(16, 0, 0, 0);
        const e = addDays(d2, 1); e.setHours(10, 0, 0, 0);
        addTask({
          title:"Overnight site prep + early install",
          typeId: typeInstall,
          people: [staffIds[0]],
          start: s.toISOString(),
          end: e.toISOString(),
          notes:"Spans days. Confirm overnight access + keys.",
          location:"CBD",
          status:"Planned",
          priority:"Urgent",
          jobNo:"SR-10288",
          customer:"City Council"
        }, {silent:true});

        // Unassigned example
        addTask({
          title:"Call supplier re: vinyl stock",
          typeId: typeDesign,
          people: [],
          start: null,
          end: null,
          notes:"No time yet — keep in unassigned until scheduled.",
          status:"Planned",
          priority:"Normal",
          jobNo:"SR-10310",
          customer:"Internal"
        }, {silent:true});

        saveState();
      }
      if(!FIREBASE_CONFIG_VALID){
        seedIfEmpty();
      }
      initFirestoreSync();

      /**********************
       * Auto-scroll helper
       **********************/
      function createEdgeAutoScroller(scrollEl, opts={}){
        const edge = opts.edge ?? 60;
        const maxSpeed = opts.maxSpeed ?? 22;
        let running = false;
        let raf = 0;
        let px = 0, py = 0;

        const setPointer = (clientX, clientY) => { px = clientX; py = clientY; };

        const tick = () => {
          if(!running) return;
          const r = scrollEl.getBoundingClientRect();

          let vx = 0, vy = 0;

          const leftDist = px - r.left;
          const rightDist = r.right - px;
          const topDist = py - r.top;
          const botDist = r.bottom - py;

          if(leftDist < edge) vx = -speedFromEdge(leftDist, edge, maxSpeed);
          else if(rightDist < edge) vx = speedFromEdge(rightDist, edge, maxSpeed);

          if(topDist < edge) vy = -speedFromEdge(topDist, edge, maxSpeed);
          else if(botDist < edge) vy = speedFromEdge(botDist, edge, maxSpeed);

          if(vx !== 0) scrollEl.scrollLeft += vx;
          if(vy !== 0) scrollEl.scrollTop += vy;

          raf = requestAnimationFrame(tick);
        };

        const start = () => {
          if(running) return;
          running = true;
          raf = requestAnimationFrame(tick);
        };

        const stop = () => {
          running = false;
          if(raf) cancelAnimationFrame(raf);
          raf = 0;
        };

        return { start, stop, setPointer };
      }

      function speedFromEdge(dist, edge, maxSpeed){
        const t = clamp((edge - dist) / edge, 0, 1);
        const eased = t * t;
        return Math.round(eased * maxSpeed);
      }

      function slotH(){
        return parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--slotH"));
      }
      function findDayColAtX(daysGridInner, xContent){
        const dayCols = Array.from(daysGridInner.querySelectorAll(".dayCol"));
        if(!dayCols.length) return { col:null, index:-1, width:0 };
        let chosen = dayCols[0];
        for(const col of dayCols){
          const left = col.offsetLeft;
          const width = col.getBoundingClientRect().width || col.offsetWidth || 0;
          if(xContent >= left && xContent < left + width){
            chosen = col;
            break;
          }
        }
        return { col: chosen, index: dayCols.indexOf(chosen), width: chosen.getBoundingClientRect().width || 0 };
      }

      let renderSlotCountOverride = null;

      function totalSlotsInView(){
        const totalMinutes = (state.settings.endHour - state.settings.startHour) * 60;
        const baseSlots = totalMinutes / SLOT_MIN;
        return renderSlotCountOverride ?? baseSlots;
      }

      function tasksOverlappingDay(day){
        const dayStart = startOfDay(day).getTime();
        const dayEnd = startOfDay(addDays(day,1)).getTime();
        return state.tasks.filter(t=>{
          if(isUnassigned(t)) return false;
          const s = new Date(t.start).getTime();
          const e = new Date(t.end).getTime();
          return e > dayStart && s < dayEnd;
        });
      }

      function fmtMonthRowForDays(days){
        if(!days || !days.length) return "";
        const first = days[0];
        const last = days[days.length - 1];
        const same = first.getFullYear()===last.getFullYear() && first.getMonth()===last.getMonth();
        if(same) return fmtMonthTitle(first);
        const a = first.toLocaleDateString(undefined, {month:"short", year:"numeric"});
        const b = last.toLocaleDateString(undefined, {month:"short", year:"numeric"});
        return `${a} → ${b}`;
      }

      function viewLabel(v){
        if(v==="day") return "Day";
        if(v==="workweek") return "Mon–Fri";
        if(v==="week") return "Week";
        if(v==="2week") return "2 weeks";
        if(v==="custom") return "Custom";
        if(v==="month") return "Month";
        return v;
      }

      function getViewDays(){
        const anchor = parseDateInput(state.ui.anchorDate);
        const view = state.ui.view;

        if(view === "month") return null;

        if(view === "day"){
          return [startOfDay(anchor)];
        }
        const base = startOfDay(anchor);
        if(view === "workweek"){
          return Array.from({length:5}, (_,i)=> addDays(base, i));
        }
        if(view === "week"){
          return Array.from({length:7}, (_,i)=> addDays(base, i));
        }
        if(view === "2week"){
          return Array.from({length:14}, (_,i)=> addDays(base, i));
        }
        if(view === "custom"){
          const n = clamp(state.ui.customDays|0, 1, 21);
          return Array.from({length:n}, (_,i)=> addDays(base, i));
        }
        return Array.from({length:7}, (_,i)=> addDays(base, i));
      }

      const boardWrap = $("#boardWrap");
      const viewSelect = $("#viewSelect");
      const customSeg = $("#customDaysSeg");
      const customDaysInput = $("#customDaysInput");
      const customDaysVal = $("#customDaysVal");
      const rangeTitle = $("#rangeTitle");
      const rangeMeta = $("#rangeMeta");
      const currentUserLabel = $("#currentUser");
      if(currentUserLabel) currentUserLabel.textContent = CURRENT_USER;

      // Unassigned panel elements
      const sidePanel = $("#sidePanel");
      const sideCloseBtn = $("#sideCloseBtn");
      const unassignedList = $("#unassignedList");
      const unassignedCount = $("#unassignedCount");
      const unassignedSearch = $("#unassignedSearch");
      const unassignedSort = $("#unassignedSort");
      const sideDropHint = $("#sideDropHint");

      sideCloseBtn.addEventListener("click", ()=>{
        state.settings.showUnassignedPanel = false;
        saveState();
        render();
      });

      function shouldShowSidePanel(){
        return !!state.settings.showUnassignedPanel;
      }

      function preserveScrollBeforeRender(){
        const dg = boardWrap.querySelector(".daysGrid");
        if(dg){
          lastScroll.timeline.x = dg.scrollLeft;
          lastScroll.timeline.y = dg.scrollTop;
        }
        const mg = boardWrap.querySelector(".monthGrid");
        if(mg){
          lastScroll.month.y = mg.scrollTop;
        }
      }

      function restoreScrollAfterRender(){
        const dg = boardWrap.querySelector(".daysGrid");
        if(dg){
          dg.scrollLeft = lastScroll.timeline.x;
          dg.scrollTop = lastScroll.timeline.y;
        }
        const mg = boardWrap.querySelector(".monthGrid");
        if(mg){
          mg.scrollTop = lastScroll.month.y;
        }
      }

      function getVisibleRangeText(){
        const view = state.ui.view;
        const anchor = parseDateInput(state.ui.anchorDate);

        if(view === "month"){
          const first = new Date(anchor.getFullYear(), anchor.getMonth(), 1);
          rangeTitle.textContent = fmtMonthTitle(first);
          rangeMeta.textContent = "Month view";
          return;
        }

        const days = getViewDays();
        const first = days[0];
        const last = days[days.length-1];
        const title = (view === "day")
          ? `${first.toLocaleDateString(undefined,{month:"short", day:"numeric", year:"numeric"})}`
          : `${first.toLocaleDateString(undefined,{month:"short", day:"numeric"})} – ${last.toLocaleDateString(undefined,{month:"short", day:"numeric", year:"numeric"})}`;
        rangeTitle.textContent = title;
        rangeMeta.textContent = `${state.ui.view === "custom" ? `${days.length} days` : viewLabel(view)} • ${SLOT_MIN} min slots`;
      }

      function clearNowLineTimer(){
        if(nowLineTimer){
          clearInterval(nowLineTimer);
          nowLineTimer = null;
        }
      }

      function shiftViewByDays(delta){
        const days = getViewDays();
        if(days && days.length){
          state.ui.anchorDate = isoDate(addDays(days[0], delta));
        }else{
          const a = parseDateInput(state.ui.anchorDate);
          state.ui.anchorDate = isoDate(addDays(a, delta));
        }
      }

      function render(){
        renderSlotCountOverride = null;
        // ✅ #4: preserve scroll before wipe
        preserveScrollBeforeRender();

        viewSelect.value = state.ui.view;
        customSeg.style.display = (state.ui.view === "custom") ? "flex" : "none";
        customDaysInput.value = state.ui.customDays;
        customDaysVal.textContent = String(state.ui.customDays);

        getVisibleRangeText();

        // side panel show/hide
        sidePanel.classList.toggle("hidden", !shouldShowSidePanel());

        clearNowLineTimer();
        boardWrap.innerHTML = "";

        if(state.ui.view === "month"){
          renderMonth(boardWrap);
        }else{
          renderTimeline(boardWrap);
        }

        renderUnassignedPanel();
        restoreScrollAfterRender();
      }

      /**********************
       * Unassigned panel
       **********************/
      function getUnassignedTasks(){
        return state.tasks.filter(isUnassigned);
      }

      function priorityRank(p){
        const v = (p||"Normal").toLowerCase();
        if(v==="urgent") return 4;
        if(v==="high") return 3;
        if(v==="normal") return 2;
        if(v==="low") return 1;
        return 2;
      }

      function renderUnassignedPanel(){
        if(!shouldShowSidePanel()){
          // still update count badge for future enable
          return;
        }

        const q = (unassignedSearch.value || "").trim().toLowerCase();
        const sort = unassignedSort.value;

        let items = getUnassignedTasks();

        if(q){
          items = items.filter(t=>{
            const hay = [
              t.title, t.customer, t.jobNo, t.notes, t.location, t.status, t.priority
            ].join(" ").toLowerCase();
            return hay.includes(q);
          });
        }

        items.sort((a,b)=>{
          const aCreated = parseInt(a.id.slice(-8), 16) || 0; // weak but consistent-ish
          const bCreated = parseInt(b.id.slice(-8), 16) || 0;

          if(sort==="new") return bCreated - aCreated;
          if(sort==="old") return aCreated - bCreated;
          if(sort==="az") return (a.title||"").localeCompare(b.title||"");
          if(sort==="za") return (b.title||"").localeCompare(a.title||"");
          if(sort==="priority") return priorityRank(b.priority) - priorityRank(a.priority);
          if(sort==="type"){
            const at = (state.types.find(x=>x.id===a.typeId)?.name||"").toLowerCase();
            const bt = (state.types.find(x=>x.id===b.typeId)?.name||"").toLowerCase();
            return at.localeCompare(bt);
          }
          return 0;
        });

        unassignedCount.textContent = String(items.length);
        unassignedList.innerHTML = "";

        if(items.length === 0){
          const empty = document.createElement("div");
          empty.className = "dropHint";
          empty.style.margin = "0";
          empty.textContent = q ? "No matches." : "No unassigned tasks.";
          unassignedList.appendChild(empty);
          return;
        }

        for(const t of items){
          const el = makeUnassignedItem(t);
          unassignedList.appendChild(el);
        }
      }

      unassignedSearch.addEventListener("input", renderUnassignedPanel);
      unassignedSort.addEventListener("change", renderUnassignedPanel);

      function makeUnassignedItem(task){
        const type = state.types.find(t=>t.id===task.typeId) || state.types[0];
        const el = document.createElement("div");
        el.className = "mTaskPill"; // reuse pill style
        el.dataset.taskId = task.id;
        el.innerHTML = `
          <div class="bar" style="background:${type.color}"></div>
          <div class="txt">${escapeHtml(task.title || "(untitled)")}</div>
          <div class="tm">${escapeHtml((task.customer || "").trim() || "—")}</div>
        `;
        el.addEventListener("click", ()=> openTaskModal(task.id));
        attachUnassignedDrag(el, task.id);
        return el;
      }

      function attachUnassignedDrag(pillEl, taskId){
        pillEl.addEventListener("pointerdown", (e)=>{
          if(e.pointerType==="mouse" && e.button!==0) return;
          e.preventDefault();

          const task = state.tasks.find(t=>t.id===taskId);
          if(!task) return;

          const daysGrid = boardWrap.querySelector(".daysGrid");
          const daysGridInner = boardWrap.querySelector(".daysGridInner");
          const gridRect = daysGrid ? daysGrid.getBoundingClientRect() : null;

          const ghost = document.createElement("div");
          ghost.className = "dragGhost";
          const type = state.types.find(t=>t.id===task.typeId) || state.types[0];
          ghost.innerHTML = `
            <div class="band" style="background:${type.color}"></div>
            <div class="inner">
              <div class="t">${escapeHtml(task.title || "(untitled)")}</div>
              ${task.customer ? `<div class="c">${escapeHtml(task.customer)}</div>` : `<div class="c"> </div>`}
              <div class="m">
                <span>${escapeHtml(type.name)}</span>
                <span>•</span>
                <span>${escapeHtml(task.priority || "Normal")}</span>
              </div>
            </div>
          `;
          document.body.appendChild(ghost);

          const pointerId = e.pointerId;
          const startX = e.clientX, startY = e.clientY;

          const moveGhost = (cx, cy) => {
            ghost.style.left = (cx + 10) + "px";
            ghost.style.top  = (cy + 10) + "px";
          };
          moveGhost(startX, startY);

          const scroller = daysGrid ? createEdgeAutoScroller(daysGrid, {edge: 70, maxSpeed: 26}) : null;
          if(scroller){
            scroller.setPointer(e.clientX, e.clientY);
            scroller.start();
          }

          // drop highlight on side
          sidePanel.classList.add("sideDropActive");

          const move = (ev)=>{
            if(ev.pointerId !== pointerId) return;
            moveGhost(ev.clientX, ev.clientY);
            if(scroller) scroller.setPointer(ev.clientX, ev.clientY);

            // show drop active if pointer over board/side
            if(isPointInside(ev.clientX, ev.clientY, sidePanel.getBoundingClientRect())){
              sidePanel.classList.add("sideDropActive");
            } else {
              sidePanel.classList.remove("sideDropActive");
            }
          };

          const up = (ev)=>{
            if(ev.pointerId !== pointerId) return;

            document.removeEventListener("pointermove", move);
            document.removeEventListener("pointerup", up);
            document.removeEventListener("pointercancel", up);

            if(scroller) scroller.stop();
            ghost.remove();

            // Determine drop target
            const droppedOnBoard = daysGrid && gridRect && isPointInside(ev.clientX, ev.clientY, gridRect);
            const droppedOnSide  = shouldShowSidePanel() && isPointInside(ev.clientX, ev.clientY, sidePanel.getBoundingClientRect());

            sidePanel.classList.remove("sideDropActive");

            if(droppedOnBoard && daysGridInner){
              const xContent = (ev.clientX - gridRect.left) + daysGrid.scrollLeft;
              const yContent = (ev.clientY - gridRect.top) + daysGrid.scrollTop;

              const { col: colTarget } = findDayColAtX(daysGridInner, xContent);
              if(colTarget){
                const dayIso = colTarget.dataset.day;
                const slot = clamp(Math.floor(yContent / slotH()), 0, totalSlotsInView()-1);

                const day = parseDateInput(dayIso);
                const start = new Date(day);
                start.setHours(state.settings.startHour, 0, 0, 0);
                start.setMinutes(start.getMinutes() + slot * SLOT_MIN);
                const end = new Date(start.getTime() + 60*60*1000); // 1 hour default

                updateTask(taskId, {
                  start: new Date(snapToSlotMs(start.getTime())).toISOString(),
                  end: new Date(snapToSlotMs(end.getTime())).toISOString()
                }, {silent:true});
                toast("Scheduled", task.title, "var(--accent)");
              }
            } else if(droppedOnSide){
              // already unassigned, do nothing
            } else {
              // dropped elsewhere, do nothing
            }
          };

          document.addEventListener("pointermove", move);
          document.addEventListener("pointerup", up);
          document.addEventListener("pointercancel", up);
        });
      }

      function isPointInside(x,y,rect){
        return x>=rect.left && x<=rect.right && y>=rect.top && y<=rect.bottom;
      }

      const GAP_PX = 6;
      const MIN_CARD_WIDTH_PX = 44;
      let currentDaysGridInner = null;
      let currentRenderedDays = [];
      let layoutRaf = null;

      function scheduleLayout(){
        if(layoutRaf) return;
        layoutRaf = requestAnimationFrame(()=> {
          layoutRaf = null;
          layoutVisibleDays();
        });
      }

      function buildOverlapClusters(segments){
        const clusters = [];
        const sorted = [...segments].sort((a,b)=> a.start - b.start || a.end - b.end);
        let current = [];
        let currentEnd = -Infinity;
        for(const seg of sorted){
          if(!current.length){
            current = [seg];
            currentEnd = seg.end;
            continue;
          }
          if(seg.start < currentEnd){
            current.push(seg);
            currentEnd = Math.max(currentEnd, seg.end);
          } else {
            clusters.push(current);
            current = [seg];
            currentEnd = seg.end;
          }
        }
        if(current.length) clusters.push(current);
        return clusters;
      }

      function assignLanes(cluster){
        const lanes = [];
        for(const seg of cluster){
          let laneIdx = -1;
          for(let i=0;i<lanes.length;i++){
            if(seg.start >= lanes[i]){
              laneIdx = i;
              break;
            }
          }
          if(laneIdx === -1){
            laneIdx = lanes.length;
            lanes.push(seg.end);
          } else {
            lanes[laneIdx] = seg.end;
          }
          seg._lane = laneIdx;
        }
        return lanes.length;
      }

      function expandAcrossEmptyLanes(cluster, laneCount){
        for(const seg of cluster){
          let left = seg._lane;
          let right = seg._lane;

          for(let cand = seg._lane + 1; cand < laneCount; cand++){
            const blocked = cluster.some(other => other._lane === cand && other.start < seg.end && seg.start < other.end);
            if(blocked) break;
            right = cand;
          }
          for(let cand = seg._lane - 1; cand >= 0; cand--){
            const blocked = cluster.some(other => other._lane === cand && other.start < seg.end && seg.start < other.end);
            if(blocked) break;
            left = cand;
          }

          seg._spanL = left;
          seg._spanR = right;
          seg._lanes = laneCount;
        }
      }

      function layoutDayColumn(colEl, dayDate){
        if(!colEl) return;
        const tasksEls = Array.from(colEl.querySelectorAll(".task"));
        if(!tasksEls.length) return;

        const dayStart = startOfDay(dayDate).getTime();
        const dayEnd = startOfDay(addDays(dayDate,1)).getTime();

        const workStart = new Date(dayDate); workStart.setHours(state.settings.startHour,0,0,0);

        const segments = [];
        for(const el of tasksEls){
          const task = state.tasks.find(t=>t.id === el.dataset.taskId);
          if(!task || isUnassigned(task)) continue;

          const startMs = new Date(task.start).getTime();
          const endMs = new Date(task.end).getTime();
          const segStart = Math.max(startMs, dayStart);
          const segEnd = Math.min(endMs, dayEnd);
          if(segEnd <= segStart) continue;

          segments.push({
            el,
            taskId: task.id,
            start: segStart,
            end: segEnd,
            task
          });
        }

        if(!segments.length) return;

        const clusters = buildOverlapClusters(segments);
        const colWidth = colEl.clientWidth;
        for(const cluster of clusters){
          const laneCount = assignLanes(cluster);
          cluster.forEach(seg=>{ seg._spanL = seg._lane; seg._spanR = seg._lane; seg._lanes = laneCount; });
          expandAcrossEmptyLanes(cluster, laneCount);

          const laneGapTotal = Math.max(0, (laneCount - 1) * GAP_PX);
          const laneWidth = (colWidth - laneGapTotal) / Math.max(1, laneCount);

          for(const seg of cluster){
            const spanL = seg._spanL;
            const spanR = seg._spanR;
            const leftPx = spanL * (laneWidth + GAP_PX);
            const widthPx = (spanR - spanL + 1) * laneWidth + (spanR - spanL) * GAP_PX;

            let topMin = minutesBetween(workStart, new Date(seg.start));
            let durMin = Math.max(SLOT_MIN, minutesBetween(new Date(seg.start), new Date(seg.end)));

            const maxMinutesRange = (renderSlotCountOverride ?? totalSlotsInView()) * SLOT_MIN;
            topMin = clamp(topMin, 0, maxMinutesRange);
            durMin = clamp(durMin, SLOT_MIN, maxMinutesRange);

            const topPx = (topMin / SLOT_MIN) * slotH();
            const hPx = Math.max(slotH(), (durMin / SLOT_MIN) * slotH());

            seg.el.style.left = `${leftPx}px`;
            seg.el.style.width = `${Math.max(MIN_CARD_WIDTH_PX, widthPx)}px`;
            seg.el.style.right = "auto";
            seg.el.style.top = `${topPx}px`;
            seg.el.style.height = `${hPx}px`;
          }
        }
      }

      function layoutVisibleDays(){
        if(!currentDaysGridInner || !currentRenderedDays?.length) return;
        currentRenderedDays.forEach(day=>{
          const col = currentDaysGridInner.querySelector(`.dayCol[data-day="${isoDate(day)}"]`);
          layoutDayColumn(col, day);
        });
      }

      /**********************
       * Timeline render
       **********************/
      function renderTimeline(root){
        const days = getViewDays();
        const today = startOfDay(new Date());
        renderSlotCountOverride = null;

        const timeline = document.createElement("div");
        timeline.className = "timeline";

        const top = document.createElement("div");
        top.className = "timelineTop";

        const timeHeader = document.createElement("div");
        timeHeader.className = "timeHeader";
        timeHeader.textContent = "Time";

        const monthBar = document.createElement("div");
        monthBar.className = "monthBar";
        const monthText = fmtMonthRowForDays(days);
        monthBar.innerHTML = `${escapeHtml(monthText)} <span class="muted">(${escapeHtml(viewLabel(state.ui.view))})</span>`;

        const daysHeader = document.createElement("div");
        daysHeader.className = "daysHeader";

        days.forEach(d=>{
          const head = document.createElement("div");
          const isToday = sameDay(d, today);
          const wideTodayEnabled = !!state.settings.wideToday && isToday;
          head.className = "dayHead" + (isToday ? " today" : "") + (wideTodayEnabled ? " wideToday" : "");
          const count = tasksOverlappingDay(d).length;

          // ✅ #5: "Wed 30"
          const dow = d.toLocaleDateString(undefined,{weekday:"short"});
          const dayNum = String(d.getDate());
          const line = `${dow} ${dayNum}`;

          head.innerHTML = `
            <div class="dLine">${escapeHtml(line)}</div>
            <div class="count">${count}</div>
          `;
          daysHeader.appendChild(head);
        });

        top.appendChild(timeHeader);
        top.appendChild(monthBar);
        top.appendChild(daysHeader);

        const bottom = document.createElement("div");
        bottom.className = "timelineBottom";

        const timeRail = document.createElement("div");
        timeRail.className = "timeRail";

        const timeRailInner = document.createElement("div");
        timeRailInner.className = "timeRailInner";

        const totalMinutes = (state.settings.endHour - state.settings.startHour) * 60;
        const baseSlots = totalMinutes / SLOT_MIN;
        const maxSlotsFromTasks = (()=> {
          let maxSlots = baseSlots;
          state.tasks.forEach(task=>{
            if(isUnassigned(task)) return;
            const start = new Date(task.start);
            const end = new Date(task.end);
            days.forEach(day=>{
              const dayStart = startOfDay(day).getTime();
              const dayEnd = startOfDay(addDays(day,1)).getTime();
              const segEnd = Math.min(end.getTime(), dayEnd);
              if(segEnd <= dayStart) return;
              const workStart = new Date(day); workStart.setHours(state.settings.startHour,0,0,0);
              const minutesFromStart = Math.max(0, minutesBetween(workStart, new Date(segEnd)));
              const slots = Math.ceil(minutesFromStart / SLOT_MIN);
              if(slots > maxSlots) maxSlots = slots;
            });
          });
          return maxSlots;
        })();
        const slotCount = Math.max(baseSlots, maxSlotsFromTasks);
        renderSlotCountOverride = slotCount;
        const paddedSlots = slotCount + 1; // extra blank space to keep labels in sync
        const paddedHeight = paddedSlots * slotH();
        timeRailInner.style.height = paddedHeight + "px";

        for(let h=state.settings.startHour; h<=state.settings.endHour; h++){
          const yMin = (h - state.settings.startHour) * 60;
          const y = (yMin / SLOT_MIN) * slotH();
          const lbl = document.createElement("div");
          lbl.className = "timeLabel";
          lbl.style.top = y + "px";
          lbl.textContent = formatHourLabel(h);
          timeRailInner.appendChild(lbl);
        }
        timeRail.appendChild(timeRailInner);

        const daysGrid = document.createElement("div");
        daysGrid.className = "daysGrid";

        const daysGridInner = document.createElement("div");
        daysGridInner.className = "daysGridInner";
        daysGridInner.style.height = paddedHeight + "px";

        days.forEach((d)=>{
          const col = document.createElement("div");
          const isToday = sameDay(d, today);
          const wideTodayEnabled = !!state.settings.wideToday && isToday;
          col.className = "dayCol" + (wideTodayEnabled ? " wideToday" : "");
          col.dataset.day = isoDate(d);

          for(let s=0; s<=slotCount; s++){
            const line = document.createElement("div");
            line.className = "slotLine";
            const y = s * slotH();
            line.style.top = y + "px";

            const minutesFromStart = s * SLOT_MIN;
            if(minutesFromStart % 60 === 0) line.classList.add("hour");
            else if(minutesFromStart % 30 === 0) line.classList.add("half");

            col.appendChild(line);
          }

          attachCreateDrag(col);
          daysGridInner.appendChild(col);
        });

        daysGrid.appendChild(daysGridInner);
        bottom.appendChild(timeRail);
        bottom.appendChild(daysGrid);

        timeline.appendChild(top);
        timeline.appendChild(bottom);
        root.appendChild(timeline);

        daysGrid.addEventListener("scroll", ()=>{
          daysHeader.scrollLeft = daysGrid.scrollLeft;
          timeRail.scrollTop = daysGrid.scrollTop;
          monthBar.scrollLeft = daysGrid.scrollLeft;
        }, {passive:true});

        // no forced scroll; preserve handles it now
        renderTasksIntoTimeline(daysGridInner, days);
        currentDaysGridInner = daysGridInner;
        currentRenderedDays = days;
        layoutVisibleDays();

        setupNowLine(daysGridInner);
        window.addEventListener("focus", () => setupNowLine(daysGridInner, {force:true}));
        document.addEventListener("visibilitychange", () => {
          if(!document.hidden) setupNowLine(daysGridInner, {force:true});
        });

        // allow dropping board tasks into side panel by drag end (handled in task drag)
      }

      function setupNowLine(daysGridInner, opts={}){
        const todayLocal = new Date();
        const todayIso = isoDate(todayLocal);
        const col = daysGridInner.querySelector(`.dayCol[data-day="${todayIso}"]`);
        if(!col) return;

        let line = col.querySelector(".nowLine");
        if(!line){
          line = document.createElement("div");
          line.className = "nowLine";
          line.innerHTML = `<div class="nowDot"></div>`;
          col.appendChild(line);
        }

        const update = () => {
          const now = new Date();
          const workStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(), state.settings.startHour, 0, 0, 0);
          const workEnd   = new Date(now.getFullYear(), now.getMonth(), now.getDate(), state.settings.endHour,   0, 0, 0);

          if(now < workStart || now > workEnd){
            line.style.display = "none";
            maybeNotifyActiveTasks(now);
            return;
          }
          line.style.display = "block";

          const minutesFromStart = (now - workStart) / 60000;
          const y = (minutesFromStart / SLOT_MIN) * slotH();
          line.style.top = `${y}px`;
          maybeNotifyActiveTasks(now);
        };

        if(opts.force) {
          if(nowLineTimer){ clearInterval(nowLineTimer); nowLineTimer = null; }
        } else {
          if(nowLineTimer) return;
        }

        update();

        const scheduleNextMinute = () => {
          const now = new Date();
          const msToNextMinute = (60 - now.getSeconds()) * 1000 - now.getMilliseconds() + 10;
          setTimeout(() => {
            update();
            if(nowLineTimer) clearInterval(nowLineTimer);
            nowLineTimer = setInterval(update, 60 * 1000);
          }, msToNextMinute);
        };

        scheduleNextMinute();
      }

      function renderTasksIntoTimeline(daysGridInner, days){
        $$(".task", daysGridInner).forEach(t=>t.remove());

        const visibleStart = startOfDay(days[0]).getTime();
        const visibleEnd = startOfDay(addDays(days[days.length-1], 1)).getTime();

        state.tasks.forEach(task=>{
          if(isUnassigned(task)) return;
          if((task.status || "").toLowerCase() === "done") {
            // still show but mark done
          }

          const start = new Date(task.start).getTime();
          const end   = new Date(task.end).getTime();
          if(end <= visibleStart || start >= visibleEnd) return;

          for(const d of days){
            const dayStart = startOfDay(d).getTime();
            const dayEnd = startOfDay(addDays(d,1)).getTime();

            const segStart = Math.max(start, dayStart);
            const segEnd = Math.min(end, dayEnd);
            if(segEnd <= segStart) continue;

            const col = daysGridInner.querySelector(`.dayCol[data-day="${isoDate(d)}"]`);
            if(!col) continue;

            const el = makeTaskElement(task, segStart, segEnd, d);
            col.appendChild(el);
          }
        });

        currentDaysGridInner = daysGridInner;
        currentRenderedDays = days;
        layoutVisibleDays();
      }

      function makeTaskElement(task, segStartMs, segEndMs, segDayDate){
        const type = state.types.find(t=>t.id===task.typeId) || state.types[0];
        const durationMin = Math.max(15, Math.round((segEndMs - segStartMs)/60000));

        const topMinutesFromDayStart = minutesBetween(
          new Date(segDayDate.getFullYear(), segDayDate.getMonth(), segDayDate.getDate(), state.settings.startHour, 0, 0, 0),
          new Date(segStartMs)
        );

        const topSlots = topMinutesFromDayStart / SLOT_MIN;
        const heightSlots = durationMin / SLOT_MIN;

        const topPx = topSlots * slotH();
        const heightPx = Math.max(slotH(), heightSlots * slotH());

        const el = document.createElement("div");
        el.className = "task";
        if((task.priority || "").toLowerCase() === "urgent") el.classList.add("urgent");
        if((task.status || "").toLowerCase() === "done") el.classList.add("done");
        el.dataset.taskId = task.id;

        el.style.top = topPx + "px";
        el.style.height = heightPx + "px";

        const people = (task.people || []).map(id => state.staff.find(s=>s.id===id)).filter(Boolean);
        const peopleChips = people.map(p=>{
          const textColor = "#0b0d12";
          return `<span class="badge" title="${escapeHtml(p.name)}" style="background:${p.color};border-color:${p.color};color:${textColor};font-weight:800;">${escapeHtml(p.name)}</span>`;
        }).join("");
        const timerBtn = task.timerStartedAt ? `
          <button class="trackIndicator running" data-action="track" title="Job tracking in progress">
            <span class="ico clock"></span>
          </button>` : "";

        const segStartStr = formatTime(new Date(segStartMs));
        const segEndStr = formatTime(new Date(segEndMs));

        const dayStart = startOfDay(segDayDate).getTime();
        const dayEnd = startOfDay(addDays(segDayDate,1)).getTime();
        const continuesFromPrev = new Date(task.start).getTime() < dayStart;
        const continuesToNext = new Date(task.end).getTime() > dayEnd;

        const customerText = (task.customer || "").trim();

        el.innerHTML = `
          <div class="band" style="background:${type.color}"></div>

          <div class="resizeHandle top" data-handle="top"><div class="resizeGrip"></div></div>
          <div class="resizeHandle bottom" data-handle="bottom"><div class="resizeGrip"></div></div>

          <div class="taskTopRow">
            <div class="taskTypeChip" title="${escapeHtml(type.name)}" style="background:${type.color};border-color:${type.color};color:#0b0d12;">
              <span class="taskTypeName">${escapeHtml(type.name)}</span>
            </div>
            <div class="taskActions">
              ${timerBtn}
              <button class="cardBtn done" data-action="done" title="Mark done">
                <span class="ico check"></span>
              </button>
            </div>
          </div>

          <div class="taskInner">
            <div class="taskTitle">${escapeHtml(task.title || "(untitled)")}</div>
            ${customerText ? `<div class="taskCustomer">${escapeHtml(customerText)}</div>` : ``}

            <div class="taskMeta">
              <span class="badge">${segStartStr}–${segEndStr}</span>
              ${continuesFromPrev ? `<span class="badge">← continues</span>` : ``}
              ${continuesToNext ? `<span class="badge">continues →</span>` : ``}
              ${task.jobNo ? `<span class="badge">#${escapeHtml(task.jobNo)}</span>` : ""}
            </div>

            <div class="chips">
              ${peopleChips}
            </div>
          </div>
        `;

        el.addEventListener("click", (e)=>{
          const btn = e.target.closest("[data-action]");
          if(!btn) return;
          const act = btn.dataset.action;
          if(act==="delete"){ e.stopPropagation(); deleteTask(task.id); }
          if(act==="track"){ e.stopPropagation(); toggleTrackingFromCard(task.id); }
          if(act==="done"){ e.stopPropagation(); markTaskDone(task.id); }
        });

        attachTaskDragAndResize(el);
        return el;
      }

      /**********************
       * Month view
       **********************/
      function renderMonth(root){
        const anchor = parseDateInput(state.ui.anchorDate);
        const firstOfMonth = new Date(anchor.getFullYear(), anchor.getMonth(), 1);
        const lastOfMonth = new Date(anchor.getFullYear(), anchor.getMonth()+1, 0);

        const firstCell = getMonday(firstOfMonth);
        const lastWeekStart = getMonday(lastOfMonth);
        const lastCell = addDays(lastWeekStart, 6);

        const month = document.createElement("div");
        month.className = "month";

        const gridWrap = document.createElement("div");
        gridWrap.className = "monthGrid";

        const header = document.createElement("div");
        header.className = "monthHeaderRow";
        header.innerHTML = ["Mon","Tue","Wed","Thu","Fri","Sat","Sun"].map(d=>`<div>${d}</div>`).join("");

        const cells = document.createElement("div");
        cells.className = "monthCells";

        const today = startOfDay(new Date());

        for(let d = new Date(firstCell); d <= lastCell; d = addDays(d,1)){
          const cell = document.createElement("div");
          const outside = d.getMonth() !== firstOfMonth.getMonth();
          cell.className = "mCell" + (outside ? " outside":"") + (sameDay(d,today) ? " today":"");
          cell.dataset.day = isoDate(d);

          const top = document.createElement("div");
          top.className = "mTop";
          top.innerHTML = `
            <div class="mDate">${escapeHtml(String(d.getDate()))}<span>${escapeHtml(d.toLocaleDateString(undefined,{weekday:"short"}))}</span></div>
            <button class="mAdd" title="Add task"><span class="ico plus" style="background: var(--text)"></span></button>
          `;

          const list = document.createElement("div");
          list.className = "mTasks";

          const tasksFor = tasksOverlappingDay(d).sort((a,b)=> new Date(a.start)-new Date(b.start));
          tasksFor.forEach(t=>{
            const type = state.types.find(x=>x.id===t.typeId) || state.types[0];
            const tStart = new Date(t.start);
            const tEnd = new Date(t.end);
            const show = `${formatTime(tStart)}–${formatTime(tEnd)}`;

            const pill = document.createElement("div");
            pill.className = "mTaskPill";
            pill.innerHTML = `
              <div class="bar" style="background:${type.color}"></div>
              <div class="txt">${escapeHtml(t.title || "(untitled)")}</div>
              <div class="tm">${escapeHtml(show)}</div>
            `;
            pill.addEventListener("click", ()=> openTaskModal(t.id));
            list.appendChild(pill);
          });

          cell.appendChild(top);
          cell.appendChild(list);

          cell.querySelector(".mAdd").addEventListener("click", (e)=>{
            e.stopPropagation();
            openTaskModal(null, { unassigned:false, startDate: isoDate(d), startTime: "08:00", endDate: isoDate(d), endTime: "09:00" });
          });

          cells.appendChild(cell);
        }

        gridWrap.appendChild(header);
        gridWrap.appendChild(cells);
        month.appendChild(gridWrap);
        root.appendChild(month);
      }

      /**********************
       * Create via drag in column
       **********************/
      function attachCreateDrag(col){
        let creating = null;

        col.addEventListener("pointerdown", (e)=>{
          if(e.target.closest(".task")) return;
          if(e.pointerType === "mouse" && e.button !== 0) return;

          const colRect = col.getBoundingClientRect();
          const y = e.clientY - colRect.top;
          const startSlot = clamp(Math.floor(y / slotH()), 0, totalSlotsInView()-1);

          const ghost = document.createElement("div");
          ghost.className = "ghostCreate";
          ghost.style.top = (startSlot * slotH()) + "px";
          ghost.style.height = (4 * slotH()) + "px"; // 1 hour default
          col.appendChild(ghost);

          creating = { pointerId: e.pointerId, dayIso: col.dataset.day, startSlot, ghost, moved:false };
          col.setPointerCapture(e.pointerId);
        });

        col.addEventListener("pointermove", (e)=>{
          if(!creating || creating.pointerId !== e.pointerId) return;
          creating.moved = true;

          const colRect = col.getBoundingClientRect();
          const y = e.clientY - colRect.top;
          const slot = clamp(Math.floor(y / slotH()), 0, totalSlotsInView());

          const a = creating.startSlot;
          const b = slot;
          const top = Math.min(a,b);
          const bottom = Math.max(a,b);

          const slotsLen = Math.max(1, bottom - top);
          creating.ghost.style.top = (top * slotH()) + "px";
          creating.ghost.style.height = (slotsLen * slotH()) + "px";
        });

        col.addEventListener("pointerup", (e)=>{
          if(!creating || creating.pointerId !== e.pointerId) return;

          const ghost = creating.ghost;
          const topPx = parseFloat(ghost.style.top);
          const hPx = parseFloat(ghost.style.height);

          const startSlot = Math.round(topPx / slotH());
          let slotLen = Math.max(1, Math.round(hPx / slotH()));

          if(!creating.moved || slotLen < 4) slotLen = 4;

          const day = parseDateInput(creating.dayIso);

          const start = new Date(day);
          start.setHours(state.settings.startHour, 0, 0, 0);
          start.setMinutes(start.getMinutes() + startSlot * SLOT_MIN);

          const end = new Date(start.getTime() + slotLen * SLOT_MS);

          ghost.remove();

          const newId = addTask({
            title: "New task",
            typeId: state.types[0]?.id ?? "",
            people: [],
            start: new Date(snapToSlotMs(start.getTime())).toISOString(),
            end: new Date(snapToSlotMs(end.getTime())).toISOString(),
            notes: "",
            location: "",
            status: "Planned",
            priority: "Normal",
            jobNo: "",
            customer: ""
          }, {silent:true});

          creating = null;
          openTaskModal(newId);
        });

        col.addEventListener("pointercancel", (e)=>{
          if(!creating || creating.pointerId !== e.pointerId) return;
          creating.ghost?.remove();
          creating = null;
        });
      }

      /**********************
       * Drag + Resize tasks
       * ✅ supports dragging into side panel to unassign
       **********************/
      function attachTaskDragAndResize(taskEl){
        const id = taskEl.dataset.taskId;

        const topHandle = taskEl.querySelector('.resizeHandle.top');
        const bottomHandle = taskEl.querySelector('.resizeHandle.bottom');

        const startResize = (handle, e)=>{
          e.preventDefault();
          e.stopPropagation();

          const task = state.tasks.find(t=>t.id===id);
          if(!task) return;
          taskEl.classList.add("resizing");

          const daysGrid = taskEl.closest(".daysGrid");
          const pointerId = e.pointerId;
          if(!daysGrid) return;

          const scroller = createEdgeAutoScroller(daysGrid, {edge: 70, maxSpeed: 26});
          daysGrid.setPointerCapture(pointerId);

          const move = (ev)=>{
            if(ev.pointerId !== pointerId) return;
            scroller.setPointer(ev.clientX, ev.clientY);

            const col = taskEl.closest(".dayCol");
            if(!col) return;

            const rect = col.getBoundingClientRect();
            const yInCol = ev.clientY - rect.top;

            const currentTop = parseFloat(taskEl.style.top) || 0;
            const currentH = parseFloat(taskEl.style.height) || slotH();

            let newTop = currentTop;
            let newH = currentH;

            if(handle === "top"){
              const slot = clamp(Math.round(yInCol / slotH()), 0, totalSlotsInView());
              newTop = slot * slotH();
              newH = (currentTop + currentH) - newTop;
              if(newH < slotH()) { newH = slotH(); newTop = (currentTop + currentH) - newH; }
            } else {
              const slot = clamp(Math.round(yInCol / slotH()), 0, totalSlotsInView());
              const bottomY = slot * slotH();
              newH = bottomY - currentTop;
              if(newH < slotH()) newH = slotH();
            }

            taskEl.style.top = newTop + "px";
            taskEl.style.height = newH + "px";
            const colDay = parseDateInput(col.dataset.day);
            const startSlot = clamp(Math.round(newTop / slotH()), 0, totalSlotsInView());
            const endSlot = Math.max(startSlot + 1, clamp(Math.round((newTop + newH) / slotH()), 0, totalSlotsInView()));
            const segStart = new Date(colDay); segStart.setHours(state.settings.startHour, 0, 0, 0); segStart.setMinutes(segStart.getMinutes() + startSlot * SLOT_MIN);
            const segEnd = new Date(colDay); segEnd.setHours(state.settings.startHour, 0, 0, 0); segEnd.setMinutes(segEnd.getMinutes() + endSlot * SLOT_MIN);
            const tObj = state.tasks.find(t=>t.id===id);
            if(tObj){
              tObj.start = new Date(snapToSlotMs(segStart.getTime())).toISOString();
              tObj.end = new Date(snapToSlotMs(segEnd.getTime())).toISOString();
              scheduleLayout();
            }
            ev.preventDefault();
          };

          const up = (ev)=>{
            if(ev.pointerId !== pointerId) return;

            daysGrid.removeEventListener("pointermove", move);
            daysGrid.removeEventListener("pointerup", up);
            daysGrid.removeEventListener("pointercancel", up);
            scroller.stop();
            try{ daysGrid.releasePointerCapture(pointerId); } catch {}

            const taskObj = state.tasks.find(t=>t.id===id);
            if(!taskObj) return;
            const finalStart = new Date(taskObj.start).toISOString();
            const finalEnd = new Date(taskObj.end).toISOString();
            updateTask(id, { start: finalStart, end: finalEnd }, {silent:true});
            taskEl.classList.remove("resizing");
            ev.preventDefault();
          };

          scroller.setPointer(e.clientX, e.clientY);
          scroller.start();
          daysGrid.addEventListener("pointermove", move);
          daysGrid.addEventListener("pointerup", up);
          daysGrid.addEventListener("pointercancel", up);
        };

        topHandle.addEventListener("pointerdown", (e)=> startResize("top", e));
        bottomHandle.addEventListener("pointerdown", (e)=> startResize("bottom", e));

        taskEl.addEventListener("pointerdown", (e)=>{
          if(e.target.closest(".resizeHandle")) return;
          if(e.target.closest("[data-action]")) return;
          if(e.pointerType === "mouse" && e.button !== 0) return;

          e.preventDefault();

          const task = state.tasks.find(t=>t.id===id);
          if(!task) return;

          const daysGrid = taskEl.closest(".daysGrid");
          const daysGridInner = taskEl.closest(".daysGridInner");
          if(!daysGrid || !daysGridInner) return;

          const startMs = new Date(task.start).getTime();
          const endMs = new Date(task.end).getTime();
          const dur = endMs - startMs;
          const origin = { startMs, endMs };

          const scroller = createEdgeAutoScroller(daysGrid, { edge: 70, maxSpeed: 26 });

          const gridRect = daysGrid.getBoundingClientRect();

          const segTopPx = parseFloat(taskEl.style.top) || 0;
          const downYContent = (e.clientY - gridRect.top) + daysGrid.scrollTop;
          const pointerOffsetY = downYContent - segTopPx;

          const pointerId = e.pointerId;
          const startX = e.clientX;
          const startY = e.clientY;
          let dragging = false;
          daysGrid.setPointerCapture(pointerId);

          const prevPointerEvents = taskEl.style.pointerEvents;
          taskEl.style.pointerEvents = "none";
          taskEl.classList.add("dragging");

          const getTargetFromPointer = (clientX, clientY) => {
            const xContent = (clientX - gridRect.left) + daysGrid.scrollLeft;
            const { col: colTarget } = findDayColAtX(daysGridInner, xContent);
            if(!colTarget) return null;

            const yContent = (clientY - gridRect.top) + daysGrid.scrollTop;
            const yTop = yContent - pointerOffsetY;
            const slot = clamp(Math.round(yTop / slotH()), 0, totalSlotsInView() - 1);

            return { colTarget, dayIso: colTarget.dataset.day, slot };
          };

          const maybeStartDrag = (ev)=>{
            if(dragging) return true;
            const dx = Math.abs(ev.clientX - startX);
            const dy = Math.abs(ev.clientY - startY);
            if(Math.max(dx, dy) > 3){
              dragging = true;
              scroller.start();
            }
            return dragging;
          };

          const move = (ev)=>{
            if(ev.pointerId !== pointerId) return;

            if(!maybeStartDrag(ev)) return;

            scroller.setPointer(ev.clientX, ev.clientY);

            const overSide = shouldShowSidePanel() && isPointInside(ev.clientX, ev.clientY, sidePanel.getBoundingClientRect());
            sidePanel.classList.toggle("sideDropActive", overSide);

            const target = getTargetFromPointer(ev.clientX, ev.clientY);
            if(!target) return;
            const { colTarget, dayIso, slot } = target;

            const targetDay = parseDateInput(dayIso);
            const start = new Date(targetDay);
            start.setHours(state.settings.startHour, 0, 0, 0);
            start.setMinutes(start.getMinutes() + slot * 15);

            const minStart = new Date(targetDay); minStart.setHours(state.settings.startHour,0,0,0);
            const maxStart = new Date(targetDay); maxStart.setHours(state.settings.endHour,0,0,0);

            let newStartMs = snapToSlotMs(start.getTime());
            const latestStart = Math.max(minStart.getTime(), maxStart.getTime() - Math.max(SLOT_MS, dur));
            newStartMs = clamp(newStartMs, minStart.getTime(), latestStart);
            const newEndMs = Math.min(maxStart.getTime(), newStartMs + dur);

            if(taskEl.parentElement !== colTarget){
              colTarget.appendChild(taskEl);
            }

            task.start = new Date(newStartMs).toISOString();
            task.end = new Date(newEndMs).toISOString();
            scheduleLayout();
            ev.preventDefault();
          };

          const endDrag = (ev)=>{
            if(ev.pointerId !== pointerId) return;

            daysGrid.removeEventListener("pointermove", move);
            daysGrid.removeEventListener("pointerup", endDrag);
            daysGrid.removeEventListener("pointercancel", endDrag);

            scroller.stop();

            taskEl.style.pointerEvents = prevPointerEvents || "";
            taskEl.classList.remove("dragging");
            try{ daysGrid.releasePointerCapture(pointerId); } catch {}

            if(!dragging){
              sidePanel.classList.remove("sideDropActive");
              openTaskModal(id);
              ev.preventDefault();
              return;
            }

            const droppedOnSide = shouldShowSidePanel() && isPointInside(ev.clientX, ev.clientY, sidePanel.getBoundingClientRect());

            sidePanel.classList.remove("sideDropActive");

            if(droppedOnSide){
              updateTask(id, { start: null, end: null }, {silent:true});
              toast("Unassigned", task.title, "var(--accent)");
              ev.preventDefault();
              return;
            }

            const target = getTargetFromPointer(ev.clientX, ev.clientY);
            if(!target){
              updateTask(id, { start: new Date(origin.startMs).toISOString(), end: new Date(origin.endMs).toISOString() }, { silent: true });
              ev.preventDefault();
              return;
            }

            const taskObj = state.tasks.find(t=>t.id===id);
            if(taskObj){
              updateTask(id, { start: taskObj.start, end: taskObj.end }, { silent: true });
            }

            ev.preventDefault();
          };

          scroller.setPointer(e.clientX, e.clientY);
          scroller.start();
          daysGrid.addEventListener("pointermove", move);
          daysGrid.addEventListener("pointerup", endDrag);
          daysGrid.addEventListener("pointercancel", endDrag);
        });
      }

      function toggleTrackingFromCard(taskId){
        const t = state.tasks.find(x=>x.id===taskId);
        if(!t) return;
        if(t.timerStartedAt){
          const elapsed = Math.max(0, Date.now() - t.timerStartedAt);
          const newTracked = (t.trackedMs || 0) + elapsed;
          updateTask(taskId, { trackedMs: newTracked, timerStartedAt: null }, {silent:true});
          if(editingTaskId === taskId){
            resetTimerState(newTracked, null);
          }
        } else {
          const startedAt = Date.now();
          updateTask(taskId, { timerStartedAt: startedAt }, {silent:true});
          if(editingTaskId === taskId){
            resetTimerState(t.trackedMs || 0, startedAt);
          }
        }
      }

      function markTaskDone(taskId){
        const t = state.tasks.find(x=>x.id===taskId);
        if(!t) return;
        updateTask(taskId, { status: "Done" }, {silent:true});
        if(editingTaskId === taskId){
          fStatus.value = "Done";
        }
      }

      function maybeNotifyActiveTasks(now){
        const ts = now.getTime();
        state.tasks.forEach(task=>{
          if(isUnassigned(task)) return;
          if((task.status || "").toLowerCase() === "done") return;
          const start = new Date(task.start).getTime();
          const end = new Date(task.end).getTime();
          const active = ts >= start && ts < end;
          if(active && !activeBeginNotifs.has(task.id)){
            toast("Begin Task", task.title || "Task", "var(--accent)", 60000);
            activeBeginNotifs.add(task.id);
          } else if(!active){
            activeBeginNotifs.delete(task.id);
          }
        });
      }

      /**********************
       * Task modal
       **********************/
      const taskModalBack = $("#taskModalBack");
      const taskModalClose = $("#taskModalClose");
      const taskModalCancel = $("#taskModalCancel");
      const deleteTaskBtn = $("#deleteTaskBtn");

      const fTitle = $("#fTitle");
      const fType = $("#fType");
      const fNewType = $("#fNewType");
      const addTypeOnFlyBtn = $("#addTypeOnFlyBtn");

      const fJob = $("#fJob");
      const fCustomer = $("#fCustomer");
      const fContactName = $("#fContactName");
      const fContactPhone = $("#fContactPhone");
      const fCustomerEmail = $("#fCustomerEmail");
      const fUnassigned = $("#fUnassigned");

      const fStartDate = $("#fStartDate");
      const fStartTime = $("#fStartTime");
      const fEndDate = $("#fEndDate");
      const fEndTime = $("#fEndTime");

      const fStatus = $("#fStatus");
      const fPriority = $("#fPriority");
      const fLocation = $("#fLocation");
      const fNotes = $("#fNotes");
      const fPromisedDate = $("#fPromisedDate");
      const promisedByEl = $("#promisedBy");
      const fFlagTokens = $("#fFlagTokens");
      const fAccessTokens = $("#fAccessTokens");
      const flagSelect = $("#flagSelect");
      const accessSelect = $("#accessSelect");
      const addFlagPreset = $("#addFlagPreset");
      const addAccessPreset = $("#addAccessPreset");
      const addFlagCustom = $("#addFlagCustom");
      const addAccessCustom = $("#addAccessCustom");

      const peoplePick = $("#peoplePick");
      const timerDisplay = $("#timerDisplay");
      const timerStartBtn = $("#timerStartBtn");
      const timerStopBtn = $("#timerStopBtn");

      let editingTaskId = null;
      let tempPeople = new Set();
      let modalTimerState = { baseMs: 0, startedAt: null };
      let modalTimerInterval = null;
      let initialPromised = { date:"", by:"" };
      let createdTaskId = null;
      const activeBeginNotifs = new Set();

      function randomNiceColor(){
        const hues = [205, 35, 265, 150, 95, 320, 15, 190];
        const h = hues[Math.floor(Math.random()*hues.length)];
        return `hsl(${h} 90% 60%)`;
      }

      function rebuildTypeSelect(){
        fType.innerHTML = state.types.map(t=> `<option value="${t.id}">${escapeHtml(t.name)}</option>`).join("");
      }

      function rebuildPeoplePick(){
        peoplePick.innerHTML = "";
        state.staff.forEach(s=>{
          const chip = document.createElement("div");
          chip.className = "badge";
          chip.style.cursor = "pointer";
          chip.style.userSelect = "none";
          chip.textContent = s.name;
          chip.style.background = s.color;
          chip.style.borderColor = s.color;
          chip.style.color = "#0b0d12";
          chip.style.fontWeight = "800";
          const applyOn = ()=>{
            const on = tempPeople.has(s.id);
            chip.style.boxShadow = on ? "0 0 0 2px rgba(255,255,255,.6)" : "none";
            chip.style.opacity = on ? "1" : "0.92";
          };
          chip.addEventListener("click", ()=>{
            if(tempPeople.has(s.id)) tempPeople.delete(s.id);
            else tempPeople.add(s.id);
            applyOn();
            patchEditingTask({ people: Array.from(tempPeople) });
          });
          applyOn();
          peoplePick.appendChild(chip);
        });
      }

      function rebuildFlagSelect(){
        flagSelect.innerHTML = state.flagOptions.map(opt=>`<option value="${escapeHtml(opt)}">${escapeHtml(opt)}</option>`).join("");
      }
      function rebuildAccessSelect(){
        accessSelect.innerHTML = state.accessOptions.map(opt=>`<option value="${escapeHtml(opt)}">${escapeHtml(opt)}</option>`).join("");
      }

      function setTimeFieldsEnabled(enabled){
        [fStartDate,fStartTime,fEndDate,fEndTime].forEach(inp=>{
          inp.disabled = !enabled;
          inp.style.opacity = enabled ? "1" : ".65";
        });
      }

      function patchEditingTask(patch, opts={}){
        if(!editingTaskId) return;
        updateTask(editingTaskId, patch, {silent: opts.silent ?? true});
      }

      function stopTimerTick(){
        if(modalTimerInterval){
          clearInterval(modalTimerInterval);
          modalTimerInterval = null;
        }
      }

      function currentTrackedMs(){
        const runningBonus = modalTimerState.startedAt ? Date.now() - modalTimerState.startedAt : 0;
        return modalTimerState.baseMs + runningBonus;
      }

      function renderTimer(){
        if(timerDisplay) timerDisplay.textContent = formatDurationHMS(currentTrackedMs());
        if(timerStartBtn) timerStartBtn.disabled = !!modalTimerState.startedAt;
        if(timerStopBtn) timerStopBtn.disabled = !modalTimerState.startedAt;
      }

      function startTimer(){
        if(modalTimerState.startedAt) return;
        modalTimerState.startedAt = Date.now();
        stopTimerTick();
        modalTimerInterval = setInterval(renderTimer, 500);
        renderTimer();
        patchEditingTask({ timerStartedAt: modalTimerState.startedAt, trackedMs: modalTimerState.baseMs });
      }

      function stopTimer(){
        if(!modalTimerState.startedAt) return;
        modalTimerState.baseMs += Math.max(0, Date.now() - modalTimerState.startedAt);
        modalTimerState.startedAt = null;
        stopTimerTick();
        renderTimer();
        patchEditingTask({ timerStartedAt: null, trackedMs: modalTimerState.baseMs });
      }

      function resetTimerState(baseMs=0, startedAt=null){
        modalTimerState = { baseMs: baseMs || 0, startedAt: startedAt || null };
        stopTimerTick();
        if(modalTimerState.startedAt){
          modalTimerInterval = setInterval(renderTimer, 500);
        }
        renderTimer();
      }

      function trackingPayloadForSave(){
        const trackedNow = currentTrackedMs();
        return {
          trackedMs: trackedNow,
          timerStartedAt: modalTimerState.startedAt ? modalTimerState.startedAt : null
        };
      }

      fUnassigned.addEventListener("change", ()=>{
        setTimeFieldsEnabled(!fUnassigned.checked);
      });

      if(timerStartBtn) timerStartBtn.addEventListener("click", startTimer);
      if(timerStopBtn) timerStopBtn.addEventListener("click", stopTimer);

      addTypeOnFlyBtn.addEventListener("click", ()=>{
        const name = (fNewType.value || "").trim();
        if(!name) return;

        const exists = state.types.find(t=>t.name.toLowerCase()===name.toLowerCase());
        if(exists){
          fType.value = exists.id;
          fNewType.value = "";
          toast("Already exists", `Using "${exists.name}"`, "var(--accent)");
          return;
        }
        const newType = { id: uid(), name, color: randomNiceColor() };
        state.types.push(newType);
        touchConfig();
        rebuildTypeSelect();
        fType.value = newType.id;
        fNewType.value = "";
        toast("Type added", name, "var(--accent)");
      });

      function openTaskModal(taskId=null, preset=null){
        if(!taskId){
          const d = preset?.startDate ? parseDateInput(preset.startDate) : parseDateInput(state.ui.anchorDate);
          const sd = isoDate(d);
          const ed = preset?.endDate ? preset.endDate : sd;
          const st = preset?.startTime || "08:00";
          const et = preset?.endTime || "09:00";
          const sdObj = parseDateInput(sd);
          const edObj = parseDateInput(ed);
          const stObj = parseTimeInput(st);
          const etObj = parseTimeInput(et);
          const start = new Date(sdObj); start.setHours(stObj.h, stObj.m,0,0);
          const end = new Date(edObj); end.setHours(etObj.h, etObj.m,0,0);
          const newId = addTask({
            title: "New task",
            typeId: state.types[0]?.id ?? "",
            people: [],
            start: new Date(snapToSlotMs(start.getTime())).toISOString(),
            end: new Date(snapToSlotMs(end.getTime())).toISOString(),
            notes: "",
            location: "",
            status: "Planned",
            priority: "Normal",
            jobNo: "",
            customer: "",
            contactName: "",
            contactPhone: "",
            customerEmail: "",
            promisedInstall: "",
            promisedBy: "",
            flags: [],
            accessFlags: []
          }, {silent:true});
          createdTaskId = newId;
          taskId = newId;
        } else {
          createdTaskId = null;
        }
        editingTaskId = taskId;
        rebuildTypeSelect();
        rebuildFlagSelect();
        rebuildAccessSelect();

        if(taskId){
          const t = state.tasks.find(x=>x.id===taskId);
          if(!t){ toast("Missing task", "Task not found", "var(--danger)"); return; }

          $("#taskModalTitle").textContent = "Edit Task";
          deleteTaskBtn.style.display = "inline-flex";

          fTitle.value = t.title || "";
          fType.value = t.typeId || (state.types[0]?.id ?? "");
          fJob.value = t.jobNo || "";
          fCustomer.value = t.customer || "";
          fContactName.value = t.contactName || "";
          fContactPhone.value = t.contactPhone || "";
          fCustomerEmail.value = t.customerEmail || "";
          fPromisedDate.value = t.promisedInstall || "";
          promisedByEl.textContent = `Saved by: ${t.promisedBy ? escapeHtml(t.promisedBy) : "—"}`;
          fFlagTokens.value = (t.flags || []).join(", ");
          fAccessTokens.value = (t.accessFlags || []).join(", ");
          initialPromised = { date: t.promisedInstall || "", by: t.promisedBy || "" };

          tempPeople = new Set(t.people || []);

          const unassigned = isUnassigned(t);
          fUnassigned.checked = unassigned;
          setTimeFieldsEnabled(!unassigned);

          if(unassigned){
            // sensible defaults shown but not used unless scheduled
            const d = parseDateInput(state.ui.anchorDate);
            fStartDate.value = isoDate(d);
            fStartTime.value = "08:00";
            fEndDate.value = isoDate(d);
            fEndTime.value = "09:00";
          } else {
            const s = new Date(t.start);
            const e = new Date(t.end);
            fStartDate.value = isoDate(s);
            fStartTime.value = `${pad2(s.getHours())}:${pad2(s.getMinutes())}`;
            fEndDate.value = isoDate(e);
            fEndTime.value = `${pad2(e.getHours())}:${pad2(e.getMinutes())}`;
          }

          fStatus.value = t.status || "Planned";
          fPriority.value = t.priority || "Normal";
          fLocation.value = t.location || "";
          fNotes.value = t.notes || "";
          resetTimerState(Number(t.trackedMs) || 0, t.timerStartedAt ? Number(t.timerStartedAt) : null);

        } else {
          $("#taskModalTitle").textContent = "New Task";
          deleteTaskBtn.style.display = "none";

          fTitle.value = "New task";
          fType.value = state.types[0]?.id ?? "";
          fJob.value = "";
          fCustomer.value = "";
          fContactName.value = "";
          fContactPhone.value = "";
          fCustomerEmail.value = "";
          fPromisedDate.value = "";
          promisedByEl.textContent = "Saved by: —";
          fFlagTokens.value = "";
          fAccessTokens.value = "";
          initialPromised = { date:"", by:"" };

          const unassigned = !!preset?.unassigned;
          fUnassigned.checked = unassigned;
          setTimeFieldsEnabled(!unassigned);

          const d = preset?.startDate ? parseDateInput(preset.startDate) : parseDateInput(state.ui.anchorDate);
          const sd = isoDate(d);
          const ed = preset?.endDate ? preset.endDate : sd;

          fStartDate.value = sd;
          fStartTime.value = preset?.startTime || "08:00";
          fEndDate.value = ed;
          fEndTime.value = preset?.endTime || "09:00";

          fStatus.value = "Planned";
          fPriority.value = "Normal";
          fLocation.value = "";
          fNotes.value = "";
          tempPeople = new Set();
          resetTimerState(0, null);
        }

        rebuildPeoplePick();
        taskModalBack.classList.add("show");
      }

      function closeTaskModal(){
        taskModalBack.classList.remove("show");
        editingTaskId = null;
        tempPeople = new Set();
        stopTimerTick();
        modalTimerState = { baseMs: 0, startedAt: null };
        renderTimer();
        initialPromised = { date:"", by:"" };
        createdTaskId = null;
      }

      taskModalClose.addEventListener("click", closeTaskModal);
      taskModalCancel.addEventListener("click", closeTaskModal);
      taskModalBack.addEventListener("click", (e)=>{ if(e.target === taskModalBack) closeTaskModal(); });

      deleteTaskBtn.addEventListener("click", ()=>{
        if(!editingTaskId) return;
        deleteTask(editingTaskId);
        closeTaskModal();
      });

      // Save button removed; all changes save immediately.
      function currentTaskObj(){
        return editingTaskId ? state.tasks.find(t=>t.id===editingTaskId) : null;
      }

      function applySchedulingFromFields(){
        if(!editingTaskId) return;
        if(fUnassigned.checked){
          patchEditingTask({ start: null, end: null });
          return;
        }
        if(!fStartDate.value || !fEndDate.value || !fStartTime.value || !fEndTime.value) return;
        const sd = parseDateInput(fStartDate.value);
        const ed = parseDateInput(fEndDate.value);
        const st = parseTimeInput(fStartTime.value);
        const en = parseTimeInput(fEndTime.value);
        const start = new Date(sd); start.setHours(st.h, st.m, 0, 0);
        const end = new Date(ed); end.setHours(en.h, en.m, 0, 0);
        let startMs = start.getTime();
        let endMs = end.getTime();
        if(endMs <= startMs){
          while(endMs <= startMs) endMs += 24*60*60*1000;
        }
        startMs = snapToSlotMs(startMs);
        endMs = snapToSlotMs(endMs);
        if(endMs - startMs < SLOT_MS) endMs = startMs + SLOT_MS;
        patchEditingTask({
          start: new Date(startMs).toISOString(),
          end: new Date(endMs).toISOString()
        });
      }

      function setPromisedDate(val){
        const promisedVal = (val || "").trim();
        const t = currentTaskObj();
        let promisedBy = "";
        if(promisedVal){
          const prevDate = t?.promisedInstall || "";
          const prevBy = t?.promisedBy || "";
          promisedBy = (promisedVal !== prevDate) ? CURRENT_USER : (prevBy || CURRENT_USER);
        }
        promisedByEl.textContent = `Saved by: ${promisedBy ? escapeHtml(promisedBy) : "—"}`;
        patchEditingTask({ promisedInstall: promisedVal, promisedBy });
      }

      function applyFlagTokens(tokens){
        const uniq = uniqTokens(tokens);
        fFlagTokens.value = uniq.join(", ");
        patchEditingTask({ flags: uniq });
      }
      function applyAccessTokens(tokens){
        const uniq = uniqTokens(tokens);
        fAccessTokens.value = uniq.join(", ");
        patchEditingTask({ accessFlags: uniq });
      }

      function addPresetFlag(token){
        if(!token) return;
        const tokens = uniqTokens(parseTokens(fFlagTokens.value).concat(token));
        applyFlagTokens(tokens);
      }
      function addPresetAccess(token){
        if(!token) return;
        const tokens = uniqTokens(parseTokens(fAccessTokens.value).concat(token));
        applyAccessTokens(tokens);
      }

      function addCustomFlagOption(val){
        const v = (val||"").trim();
        if(!v) return;
        if(!state.flagOptions.includes(v)){
          state.flagOptions.push(v);
          saveState();
          rebuildFlagSelect();
        }
        addPresetFlag(v);
      }
      function addCustomAccessOption(val){
        const v = (val||"").trim();
        if(!v) return;
        if(!state.accessOptions.includes(v)){
          state.accessOptions.push(v);
          saveState();
          rebuildAccessSelect();
        }
        addPresetAccess(v);
      }

      // Immediate save bindings
      fTitle.addEventListener("input", ()=> patchEditingTask({ title: (fTitle.value||"").trim() || "New task" }));
      fType.addEventListener("change", ()=> patchEditingTask({ typeId: fType.value || (state.types[0]?.id ?? "") }));
      fJob.addEventListener("input", ()=> patchEditingTask({ jobNo: (fJob.value||"").trim() }));
      fCustomer.addEventListener("input", ()=> patchEditingTask({ customer: (fCustomer.value||"").trim() }));
      fContactName.addEventListener("input", ()=> patchEditingTask({ contactName: fContactName.value || "" }));
      fContactPhone.addEventListener("input", ()=> patchEditingTask({ contactPhone: fContactPhone.value || "" }));
      fCustomerEmail.addEventListener("input", ()=> patchEditingTask({ customerEmail: fCustomerEmail.value || "" }));
      fStatus.addEventListener("change", ()=> patchEditingTask({ status: fStatus.value || "Planned" }));
      fPriority.addEventListener("change", ()=> patchEditingTask({ priority: fPriority.value || "Normal" }));
      fLocation.addEventListener("input", ()=> patchEditingTask({ location: fLocation.value || "" }));
      fNotes.addEventListener("input", ()=> patchEditingTask({ notes: fNotes.value || "" }));

      fPromisedDate.addEventListener("change", ()=> setPromisedDate(fPromisedDate.value));
      fFlagTokens.addEventListener("input", ()=> applyFlagTokens(parseTokens(fFlagTokens.value)));
      fAccessTokens.addEventListener("input", ()=> applyAccessTokens(parseTokens(fAccessTokens.value)));

      addFlagPreset.addEventListener("click", (e)=>{ e.preventDefault(); addPresetFlag(flagSelect.value); });
      addAccessPreset.addEventListener("click", (e)=>{ e.preventDefault(); addPresetAccess(accessSelect.value); });
      addFlagCustom.addEventListener("click", (e)=>{ e.preventDefault(); addCustomFlagOption(fFlagTokens.value); });
      addAccessCustom.addEventListener("click", (e)=>{ e.preventDefault(); addCustomAccessOption(fAccessTokens.value); });

      fUnassigned.addEventListener("change", ()=>{
        setTimeFieldsEnabled(!fUnassigned.checked);
        if(fUnassigned.checked){
          patchEditingTask({ start: null, end: null });
        } else {
          applySchedulingFromFields();
        }
      });
      fStartDate.addEventListener("change", applySchedulingFromFields);
      fEndDate.addEventListener("change", applySchedulingFromFields);
      fStartTime.addEventListener("change", applySchedulingFromFields);
      fEndTime.addEventListener("change", applySchedulingFromFields);

      /**********************
       * Settings modal
       **********************/
      const settingsModalBack = $("#settingsModalBack");
      const settingsBtn = $("#settingsBtn");
      const settingsClose = $("#settingsClose");
      const settingsCancel = $("#settingsCancel");
      const settingsSave = $("#settingsSave");
      const resetDataBtn = $("#resetDataBtn");

      const sStartHour = $("#sStartHour");
      const sEndHour = $("#sEndHour");
      const sTimeFormat = $("#sTimeFormat");
      const sShowUnassigned = $("#sShowUnassigned");
      const sWideToday = $("#sWideToday");

      const staffList = $("#staffList");
      const newStaffName = $("#newStaffName");
      const newStaffColor = $("#newStaffColor");
      const addStaffBtn2 = $("#addStaffBtn2");

      const typeList = $("#typeList");

      settingsBtn.addEventListener("click", openSettings);
      settingsClose.addEventListener("click", closeSettings);
      settingsCancel.addEventListener("click", closeSettings);
      settingsModalBack.addEventListener("click", (e)=>{ if(e.target===settingsModalBack) closeSettings(); });

      function openSettings(){
        sStartHour.value = state.settings.startHour;
        sEndHour.value = state.settings.endHour;
        sTimeFormat.value = state.settings.timeFormat || "12";
        sShowUnassigned.checked = !!state.settings.showUnassignedPanel;
        sWideToday.checked = !!state.settings.wideToday;
        renderStaffList();
        renderTypeList();
        settingsModalBack.classList.add("show");
      }
      function closeSettings(){ settingsModalBack.classList.remove("show"); }

      function renderStaffList(){
        staffList.innerHTML = "";
        state.staff.forEach((s, idx)=>{
          const row = document.createElement("div");
          row.className = "itemRow";
          row.innerHTML = `
            <div class="swatch" style="background:${s.color}"></div>
            <input type="text" value="${escapeHtml(s.name)}" data-k="name" />
            <input type="color" value="${s.color}" data-k="color" />
            <button class="btn danger" style="height:34px" title="Remove">Remove</button>
          `;
          const nameInp = row.querySelector('input[data-k="name"]');
          const colorInp = row.querySelector('input[data-k="color"]');
          const rm = row.querySelector("button");

          nameInp.addEventListener("input", ()=>{ s.name = nameInp.value; touchConfig(); });
          colorInp.addEventListener("input", ()=>{
            s.color = colorInp.value;
            row.querySelector(".swatch").style.background = s.color;
            touchConfig();
          });
          rm.addEventListener("click", ()=>{
            state.staff.splice(idx,1);
            state.tasks.forEach(t=>{ t.people = (t.people||[]).filter(pid=>pid!==s.id); });
            renderStaffList();
            touchConfig();
          });

          staffList.appendChild(row);
        });
      }

      function renderTypeList(){
        typeList.innerHTML = "";
        state.types.forEach((t, idx)=>{
          const row = document.createElement("div");
          row.className = "itemRow";
          row.innerHTML = `
            <div class="swatch" style="background:${t.color}"></div>
            <input type="text" value="${escapeHtml(t.name)}" data-k="name" />
            <input type="color" value="${t.color}" data-k="color" />
            <button class="btn danger" style="height:34px" title="Remove">Remove</button>
          `;
          const nameInp = row.querySelector('input[data-k="name"]');
          const colorInp = row.querySelector('input[data-k="color"]');
          const rm = row.querySelector("button");

          nameInp.addEventListener("input", ()=>{ t.name = nameInp.value; touchConfig(); });
          colorInp.addEventListener("input", ()=>{
            t.color = colorInp.value;
            row.querySelector(".swatch").style.background = t.color;
            touchConfig();
          });
          rm.addEventListener("click", ()=>{
            if(state.types.length <= 1){
              toast("Can't remove", "Need at least one task type", "var(--danger)");
              return;
            }
            const removedId = t.id;
            state.types.splice(idx,1);
            const fallbackId = state.types[0].id;
            state.tasks.forEach(task=>{ if(task.typeId === removedId) task.typeId = fallbackId; });
            renderTypeList();
            touchConfig();
          });

          typeList.appendChild(row);
        });
      }

      addStaffBtn2.addEventListener("click", ()=>{
        const name = (newStaffName.value||"").trim();
        if(!name) return;
        state.staff.push({ id: uid(), name, color: newStaffColor.value || "#4ea1ff" });
        newStaffName.value = "";
        renderStaffList();
        touchConfig();
      });

      resetDataBtn.addEventListener("click", ()=>{
        if(!confirm("Reset local data? This wipes tasks + settings.")) return;
        localStorage.removeItem(LS_KEY);
        state = defaultState();
        if(!FIREBASE_CONFIG_VALID){
          seedIfEmpty();
        }
        toast("Reset", "Local data wiped", "var(--danger)");
        closeSettings();
        render();
      });

      settingsSave.addEventListener("click", ()=>{
        let sh = parseInt(sStartHour.value, 10);
        let eh = parseInt(sEndHour.value, 10);
        if(Number.isNaN(sh)) sh = 6;
        if(Number.isNaN(eh)) eh = 18;
        sh = clamp(sh, 0, 23);
        eh = clamp(eh, 1, 24);
        if(eh <= sh){
          toast("Invalid hours", "End must be after start", "var(--danger)");
          return;
        }

        state.settings.startHour = sh;
        state.settings.endHour = eh;
        state.settings.timeFormat = sTimeFormat.value || "12";
        state.settings.showUnassignedPanel = !!sShowUnassigned.checked;
        state.settings.wideToday = !!sWideToday.checked;

        saveState();
        toast("Saved", "Settings updated", "var(--accent)");
        closeSettings();
        render();
      });

      /**********************
       * Header controls
       **********************/
      $("#addTaskBtn").addEventListener("click", ()=>{
        // If panel enabled, default to unassigned? No—keep scheduled default.
        const anchor = parseDateInput(state.ui.anchorDate);
        const d = (state.ui.view==="month") ? startOfDay(anchor) : getViewDays()[0];
        openTaskModal(null, { unassigned:false, startDate: isoDate(d), startTime:"08:00", endDate: isoDate(d), endTime:"09:00" });
      });

      $("#todayBtn").addEventListener("click", ()=>{
        state.ui.anchorDate = isoDate(new Date());
        saveState();
        render();
      });

      $("#prevDayBtn").addEventListener("click", ()=>{
        shiftViewByDays(-1);
        saveState(); render();
      });

      $("#nextDayBtn").addEventListener("click", ()=>{
        shiftViewByDays(1);
        saveState(); render();
      });

      $("#prevBtn").addEventListener("click", ()=>{
        const a = parseDateInput(state.ui.anchorDate);
        if(state.ui.view==="month"){
          state.ui.anchorDate = isoDate(new Date(a.getFullYear(), a.getMonth()-1, 1));
        } else {
          const step = 7;
          state.ui.anchorDate = isoDate(addDays(a, -step));
        }
        saveState(); render();
      });

      $("#nextBtn").addEventListener("click", ()=>{
        const a = parseDateInput(state.ui.anchorDate);
        if(state.ui.view==="month"){
          state.ui.anchorDate = isoDate(new Date(a.getFullYear(), a.getMonth()+1, 1));
        } else {
          const step = 7;
          state.ui.anchorDate = isoDate(addDays(a, step));
        }
        saveState(); render();
      });

      viewSelect.addEventListener("change", ()=>{
        state.ui.view = viewSelect.value;
        saveState(); render();
      });

      customDaysInput.addEventListener("input", ()=>{
        state.ui.customDays = parseInt(customDaysInput.value, 10);
        customDaysVal.textContent = String(state.ui.customDays);
      });
      customDaysInput.addEventListener("change", ()=>{
        saveState(); render();
      });

      window.addEventListener("keydown", (e)=>{
        if(e.key === "Escape"){
          if(taskModalBack.classList.contains("show")) closeTaskModal();
          if(settingsModalBack.classList.contains("show")) closeSettings();
        }
      });

      render();

    });
  })();
  </script>
</body>
</html>
